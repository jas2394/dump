<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>JavaScript: The Complete Reference&#153;, Third Edition</title>
<link href="0071741216.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta content="urn:uuid:4d1be0af-c0d3-47b8-9bd4-3edcb4dee196" name="Adept.expected.resource"/>
</head>
<body>
<h3 class="h3b" id="ch06"><a id="page_181"/><strong>CHAPTER 6<br/>Objects</strong></h3>
<p class="indent">In slight contrast to many languages that are referred to as “object-oriented” (a concept we’ll explore briefly later in this chapter), JavaScript is actually an “object-based” language. In JavaScript, practically everything is an object, except for language constructs, keywords, and operators. Objects in JavaScript play many different roles, from representing data types to manipulation of HTML documents via the <span class="codesample">Document</span> Object Model (DOM), to interfacing with the browser, and more. Object-based programming in JavaScript is what unlocks the <span class="codesample">true</span> power of the language. While previous chapters presented examples that implicitly demonstrated the use of native (built-in) objects, this chapter explores JavaScript objects directly and in-depth.</p>
<h4 class="h4"><a id="ch06lev1sec1"/><strong>Objects in JavaScript</strong></h4>
<p class="noindent">Objects in JavaScript fall into four groups:</p>
<p class="bullettop">• <em>User-defined</em> objects are custom objects created by the programmer to bring structure and consistency to a particular programming task. Objects can be nested within other objects, and this allows the programmer to create arbitrarily complex data structures consisting of data (properties) and behavior (methods) for desired tasks. The programmer can collect all the data and functions related to a specific task into a single unit: an object. The importance of this pattern will be demonstrated throughout this chapter.</p>
<p class="bullet">• <em>Native</em> objects are provided by the JavaScript language itself. These include objects associated with data types such as <span class="codesample">String</span>, <span class="codesample">Number</span>, and <span class="codesample">Boolean</span>, as well as objects that allow creation of user-defined objects and composite types, such as <span class="codesample">Object</span> and <span class="codesample">Array</span>. Native objects also include JavaScript functions, such as <span class="codesample">Function</span>, as well as other objects that simplify common tasks, such as <span class="codesample">Date</span>, <span class="codesample">Math</span>, and <span class="codesample">RegExp</span> manipulation. Other miscellaneous objects for exception handling, such as <span class="codesample">Error</span>, are also native. The capabilities of native objects are governed by the ECMAScript language standard and, to a lesser extent, by the specifications of particular browser vendors. The following two chapters discuss the features of native objects.</p>
<p class="bullet"><a id="page_182"/>• <em>Host</em> objects are those objects that are not specified as part of the JavaScript language but that are supported by most host environments, typically browsers. Examples of browser-based host objects include <span class="codesample">window</span>, the object that enables the manipulation of browser windows and interaction with the user, and <span class="codesample">navigator</span>, the object that provides information about client configuration. Most aspects of host objects were not initially governed by any standard, though today the HTML5 specification does attempt to address this oversight. Because of the lack of clear ownership, the properties and behavior of host objects can vary significantly from browser to browser and from version to version. These types of objects will be discussed throughout the rest of the book and in <a class="nounder" href="ch09.html#ch09">Chapter 9</a> particularly.</p>
<hr/>
<p class="note"><strong>NOTE</strong> As JavaScript can be hosted in other environments besides browsers—for example, server-side JavaScript—host objects vary quite a bit depending on context of use. We do not discuss server host objects given the lack of any consensus on what will actually be supported consistently across server-side implementations.</p>
<p class="bullet">• <em>Document</em> objects are part of the <span class="codesample">Document</span> Object Model (DOM), as defined by the W3C. These objects present the programmer with a structured interface to HTML and XML documents. Access to the document objects is provided by the browser via the <span class="codesample">document</span> property of the <span class="codesample">window</span> object (<span class="codesample">window.document</span>). An in-depth discussion of the DOM can be found in <a class="nounder" href="ch10.html#ch10">Chapter 10</a>.</p>
<p class="indent">The objects in JavaScript are summarized in <a class="nounder" href="ch06.html#tab6-1">Table 6-1</a>.</p>
<p class="tabcap"><a id="tab6-1"/><strong>Table 6-1</strong> Overview of JavaScript Object Classifications</p>
<p class="image"><img alt="image" src="t0182-01.jpg"/></p>
<p class="indent">At times, particularly in the past, some overlap has existed in these four categories, mainly because there is no one standard governing the intersection of browser and document. The ECMAScript standard governs the language itself. The W3C’s DOM specification dictates how structured documents such as Web pages should be presented to a scripting environment. Browser vendors define access to the user interface as they see fit and even create their own proprietary extensions to the DOM. The result is a chaotic and somewhat confusing set of technologies that come together under the umbrella of what we think of when we say “JavaScript.”</p>
<p class="indent">The primary complications in JavaScript have to do with differences among various browser implementations of certain “host environment” details, such as the DOM and event handling. For this reason, JavaScript libraries or frameworks, including jQuery, Dojo, YUI, and Prototype, have become popular, as well as dozens of others. These frameworks <a id="page_183"/>attempt to smooth over the differences between different browser implementations of object models and event handling.</p>
<p class="indent">This chapter covers the fundamental ways that objects behave and can be manipulated in JavaScript. First it will illustrate how objects in JavaScript work by examining native objects; then it will extend these techniques to user-defined objects. The specific capabilities of native, host, and document objects will be discussed in further detail in chapters that follow.</p>
<h4 class="h4"><a id="ch06lev1sec2"/><strong>Object Fundamentals</strong></h4>
<p class="noindent">An <em>object</em> is an unordered collection of data, including primitive types, functions, and even other objects. The utility of objects is that they gather all the data and behavior necessary for a particular task in one place. For example, a <span class="codesample">String</span> object stores textual data and also provides many of the functions you need to operate on the data. While objects aren’t strictly necessary in a programming language (for example, C has no objects), when properly employed they can bring a sense of order and maintainability to code—and this is quite useful, particularly when dealing with large and complex programs.</p>
<h5 class="h5"><a id="ch06lev2sec1"/><strong>Object Creation</strong></h5>
<p class="noindent">An object is created with a <em>constructor</em>, a special type of function that prepares a new object for use by initializing the memory it takes up. In <a class="nounder" href="ch04.html#ch04">Chapter 4</a>, we saw how objects are created by applying the <span class="codesample">new</span> operator to their constructors. This operator causes the constructor to which it is applied to create a brand-new object, and the nature of the object that is created is determined by the particular constructor that is invoked. For example, the <span class="codesample">String()</span> constructor creates <span class="codesample">String</span> objects while the <span class="codesample">Array()</span> constructor creates <span class="codesample">Array</span> objects. This is actually the way object types are named in JavaScript: after the constructor that creates them.</p>
<p class="indent">A simple example of object creation is shown here:</p>
<p class="image"><img alt="image" src="f0183-01.jpg"/></p>
<p class="noindent">This statement creates a new <span class="codesample">String</span> object and places a reference to it in the variable <span class="codesample"><em>city</em></span>. Because no argument was given to the constructor, <span class="codesample"><em>city</em></span> is assigned the default value for strings, the empty string. We could have made the example more interesting by passing the constructor an argument specifying an initial value:</p>
<p class="image"><img alt="image" src="f0183-02.jpg"/></p>
<p class="noindent">This places a reference to a new <span class="codesample">String</span> object with the value “<span class="codesample">San Diego</span>” in <span class="codesample"><em>city</em></span>.</p>
<p class="indent">We are not limited to declaring only native objects such as <span class="codesample">String</span> and <span class="codesample">Array</span>; <a class="nounder" href="ch04.html#ch04">Chapter 4</a> also alluded to the creation of <span class="codesample">Object</span> objects. These generic objects can be used to create user-defined data types, and they are, therefore, one of the most powerful tools available for writing nontrivial JavaScript code.</p>
<p class="indent">As with any object in JavaScript, you can add properties to a user-defined object dynamically:</p>
<p class="image"><img alt="image" src="f0183-03.jpg"/></p>
<p class="indent"><a id="page_184"/>You can, of course, also add functions dynamically. The following code extends the previous simple example by adding a method to the <span class="codesample"><em>robot</em></span> object. We first define the function and then add it to the object:</p>
<p class="image"><img alt="image" src="f0184-01.jpg"/></p>
<p class="noindent">Note that the <span class="codesample"><em>attack</em></span> property is set to the name of the function with no parentheses. If the parentheses were added, the function would execute and <span class="codesample"><em>attack</em></span> would be set to the results of the function.</p>
<p class="indent">Notice that we named the method <span class="codesample"><em>attack</em></span>, even though the function was named <span class="codesample"><em>strikeIntruder</em></span>. We could have named it anything; the interpreter does not care what identifier we choose to use. Let’s invoke the method:</p>
<p class="image"><img alt="image" src="f0184-02.jpg"/></p>
<p class="noindent">We could have written this example without even naming the function we called <span class="codesample"><em>strikeIntruder()</em></span>.</p>
<p class="image"><img alt="image" src="f0184-03.jpg"/></p>
<p class="noindent">A functional literal syntax is more compact and avoids cluttering the global namespace with a function that will be used only as a method of a user-defined object.</p>
<h6 class="h6"><strong>Object Literals</strong></h6>
<p class="noindent">Because JavaScript supports literal syntax for many data types (for example, numbers, strings, arrays, and functions), it should come as no surprise that <span class="codesample">Object</span> literals are also supported in JavaScript. The syntax is a curly braces–enclosed, comma-separated list of property/value pairs. Property/value pairs are specified by giving a property name, followed by a colon, and then its value. Here, we restate the previous example using both object and function literals:</p>
<p class="image"><img alt="image" src="f0184-04.jpg"/></p>
<p class="noindent">And we can invoke <span class="codesample"><em>robot.attack()</em></span> with the same result as before.</p>
<p class="indent">The <span class="codesample">{…}</span> object literal syntax is functionally equivalent to calling <span class="codesample">new Object()</span>, with the added benefit that you can specify the properties directly in the object literal syntax, while you have to declare separate assignment statements subsequent to a <span class="codesample">new Object()</span> statement. However, it is generally regarded as faster, and thus preferable, to use the <span class="codesample">{…}</span> object literal syntax, even if declaring an initially empty object.</p>
<p class="indent">This example also hints at the robustness of these capabilities. It is perfectly valid to specify nested literals, properties with <span class="codesample">null</span> or <span class="codesample">undefined</span> values, and values that are not literals (that is, values that are variables). The following code illustrates these concepts in an example similar to those we’ve previously seen:</p>
<p class="image"><a id="page_185"/><img alt="image" src="f0185-01.jpg"/></p>
<p class="noindent">There is a fair amount going on here that might require explanation. First, notice that <span class="codesample"><em>robot</em></span> object’s property <span class="codesample"><em>hasJetpack</em></span> is set through another variable, <span class="codesample"><em>jetpack</em></span>. Also note that the <span class="codesample"><em>robot.name</em></span> is initially set to <span class="codesample">null</span>, but it is later filled in with the appropriate value. The major change is that <span class="codesample"><em>robot</em></span> contains a nested object called <span class="codesample"><em>sidekick</em></span>, which also contains three properties— <span class="codesample"><em>name, model, hasJetpack</em></span>—and an <span class="codesample"><em>attack()</em></span> method. Invoking <span class="codesample"><em>robot.attack()</em></span> results in the now-familiar “ZAP!” output. Here’s the method call:</p>
<p class="image"><img alt="image" src="f0185-02.jpg"/></p>
<p class="indent">If the way the <span class="codesample"><em>robot</em></span> object has been defined in the previous examples seems bulky and inelegant to you, your programming instincts are very good. There is a better way to create your own objects that makes much better use of the object-oriented nature of JavaScript. We’ll explore that a little later in the chapter, but for now these examples should illustrate the options you have with regard to direct object declaration.</p>
<h5 class="h5"><a id="ch06lev2sec2"/><strong>Object Destruction and Garbage Collection</strong></h5>
<p class="noindent">Objects and other variables use memory in the browser, so when you create objects in JavaScript, the interpreter automatically allocates memory for you to use. It also “cleans up” after you. This language feature is called <em>garbage collection</em>. Unlike some languages, which require strict memory management, JavaScript is more forgiving and will attempt to manage the memory as best it can. In most cases, it’s best to let JavaScript take care of these tasks.</p>
<p class="indent">Garbage-collecting languages such as JavaScript keep a watchful eye on your data. When a piece of data is no longer accessible to your program, the space it occupies is reclaimed by the interpreter and returned to the pool of available memory. For example, in the following code, the initially allocated <span class="codesample">String</span> that references “Roy” will eventually be returned to the free pool because it is no longer accessible (that is, the reference to it was replaced by a reference to the object containing the sentence about Deckard):</p>
<p class="image"><img alt="image" src="f0185-03.jpg"/></p>
<p class="indent">If your code involves large amounts of data, giving the interpreter hints that you are done with specific variables can be useful in keeping the memory footprint of your script to a reasonable level. An easy way to do this is to replace unneeded data with <span class="codesample">null</span>, indicating that the variable is now empty. For example, supposing you had a <span class="codesample"><em>Book</em></span> object:</p>
<p class="image"><img alt="image" src="f0185-04.jpg"/></p>
<p class="image"><a id="page_186"/><img alt="image" src="f0186-01.jpg"/></p>
<p class="noindent">The last statement indicates unequivocally that you have finished with the data referenced by <span class="codesample"><em>myBook</em></span> and that, therefore, the many megabytes of memory it took up may be reused.</p>
<hr/>
<p class="note"><strong>NOTE</strong> If you have multiple references to the same data, be sure that you set them all to <span class="codesample">null</span>; otherwise, the garbage collector thinks some part of your code may still need the data, so it keeps it around just in case.</p>
<h5 class="h5"><a id="ch06lev2sec3"/><strong>Properties</strong></h5>
<p class="noindent">A <em>property</em> of an object is some piece of named data it contains. As discussed in <a class="nounder" href="ch04.html#ch04">Chapter 4</a>, properties are accessed with the dot (<span class="codesample">.</span>) operator applied to an object. For example,</p>
<p class="image"><img alt="image" src="f0186-02.jpg"/></p>
<p class="noindent">accesses the <span class="codesample">length</span> property of the <span class="codesample">String</span> object referenced by <span class="codesample"><em>myString</em></span>.</p>
<p class="indent">Accessing a property that does not exist returns an <span class="codesample">undefined</span> value:</p>
<p class="image"><img alt="image" src="f0186-03.jpg"/></p>
<p class="indent">In <a class="nounder" href="ch04.html#ch04">Chapter 4</a>, we also saw how it’s easy to use <em>instance properties</em>, properties added dynamically by script code:</p>
<p class="image"><img alt="image" src="f0186-04.jpg"/></p>
<p class="noindent">Instance properties are so-named because they are present only in the particular object or <em>instance</em> to which they were added, as opposed to properties such as <span class="codesample">String.length</span>, which are always provided in every instance of a <span class="codesample">String</span> object. Instance properties are useful for augmenting or annotating existing objects for some specific use:</p>
<p class="image"><img alt="image" src="f0186-05.jpg"/></p>
<hr/>
<p class="note"><strong>NOTE</strong> JavaScript does provide the ability to add a property to all instances of a particular object through object prototypes. Prototypes will be discussed, along with the details of JavaScript’s inheritance features, in the section “Prototypes,” later in this chapter.</p>
<p class="indent">You can remove instance properties with the <span class="codesample">delete</span> operator. The following example illustrates the deletion of an instance property that we added to a <span class="codesample">String</span> object:</p>
<p class="image"><a id="page_187"/><img alt="image" src="f0187-01.jpg"/></p>
<p class="noindent">As you can see after removal with <span class="codesample">delete</span>, the <span class="codesample"><em>simpleExample</em></span> property has the <span class="codesample">undefined</span> value, just as any nonexistent property would.</p>
<hr/>
<p class="note"><strong>NOTE</strong> C++ and Java programmers should be aware that JavaScript’s <span class="codesample">delete</span> is not the same as in those languages. It is used only to remove properties from objects and elements from arrays. In the previous example, you cannot delete <span class="codesample">myString</span> itself, though attempting to do so will fail silently.</p>
<h6 class="h6"><strong>Valid Property Names</strong></h6>
<p class="noindent">In addition to JavaScript’s syntactic rules about valid characters in property names, there are some other important limitations to note. A word used in the “key” position (that is, the property name) of an object literal, or used with the dot (.) operator syntax, currently cannot be one of JavaScript’s reserved words (<span class="codesample">for, while</span>, and so on). If the property name is surrounded by quotes (either in the object literal or used with the <span class="codesample">[ ]</span> operator syntax on the object), then no such restriction exists. It’s also important to note that this restriction has been lifted as of ECMAScript 5, so eventually it will no longer be an issue.</p>
<h6 class="h6"><strong>Detecting if Properties Exist on an Object</strong></h6>
<p class="noindent">We have already seen how to create, access, and delete properties on objects (native and user-defined). But another very common task for developers is how to determine if a property currently exists on an object. There are a few ways to accomplish this:</p>
<p class="image"><img alt="image" src="f0187-02.jpg"/></p>
<p class="noindent">These different techniques have different implications, so their use should be considered carefully.</p>
<p class="indent">Use of the “truthy” test for an object’s property is a common pattern, and under specific conditions is safe. But if the property in question can ever be assigned any kind of nontruthy value, such as <span class="codesample">false</span>, <span class="codesample">0</span>, <span class="codesample">“ “</span>, <span class="codesample">null</span>, <span class="codesample">undefined</span>, or <span class="codesample">NaN</span>, this test will fail even if the property exists on the object but has one of those values.</p>
<p class="indent">The <span class="codesample">typeof</span> operator check for property existence is effective, but its wordiness may be stylistically undesirable.</p>
<p class="indent"><a id="page_188"/>As opposed to the previous two techniques, the <span class="codesample">in</span> operator requires the property name to be expressed as a string, which also may be awkward; however, this technique has become popular, particularly when detecting properties in DOM objects.</p>
<p class="indent">The <span class="codesample">hasOwnProperty()</span> technique also requires the property name as a string and will check if an object has the property directly on that instance (and thus is not just an inherited prototype property).</p>
<p class="indent">It should be noted that there are other methods for accomplishing property detection, but some are a bit esoteric or just are variations of the same approach, so we omit those in favor of the readable techniques.</p>
<h6 class="h6"><strong>Accessing Properties with the Array Syntax</strong></h6>
<p class="noindent">An equivalent, but sometimes more convenient, alternative to the dot operator is the array (<span class="codesample">[ ]</span>) operator. It enables you to access the property given by the string passed within the brackets. For example:</p>
<p class="image"><img alt="image" src="f0188-01.jpg"/></p>
<p class="indent">Programmers either prefer or dislike this method of accessing properties simply for stylistic reasons. However, there are two legitimate reasons to use this syntax. First off, you may use properties with spaces in them when employing this syntax:</p>
<p class="image"><img alt="image" src="f0188-02.jpg"/></p>
<p class="noindent">Second, you may easily use a variable as your accessor, like so:</p>
<p class="image"><img alt="image" src="f0188-03.jpg"/></p>
<p class="noindent">To perform a similar action with the dot accessor scheme, we would have to employ <span class="codesample">eval()</span>, which is not recommended, particularly since it is unavailable in ECMAScript 5 strict mode. The same approach written in the other style is shown for comparison:</p>
<p class="image"><img alt="image" src="f0188-04.jpg"/></p>
<p class="noindent"><a id="page_189"/>Regardless of the acceptability of <span class="codesample">eval()</span>, the second solution is not as robust due to the usage of the spaced property.</p>
<h6 class="h6"><strong>Methods</strong></h6>
<p class="noindent">Object members that are functions are called <em>methods.</em> Like properties, they are typically accessed with the dot operator. The following example illustrates invoking the <span class="codesample">toUpperCase()</span> method of the <span class="codesample">String</span> object:</p>
<p class="image"><img alt="image" src="f0189-01.jpg"/></p>
<p class="noindent">You could also use the array syntax:</p>
<p class="image"><img alt="image" src="f0189-02.jpg"/></p>
<p class="noindent">but this convention is rarely used.</p>
<p class="indent">Setting instance methods is just like setting instance properties:</p>
<p class="image"><img alt="image" src="f0189-03.jpg"/></p>
<h6 class="h6"><strong>Enumerating Properties</strong></h6>
<p class="noindent">JavaScript provides a variation of the <span class="codesample">for</span> loop called the <span class="codesample">for-in</span> loop. This construct allows an enumeration of all of an object’s instance properties without knowing the property names ahead of time. As such, it can be very useful to traverse an entire object without knowing the contents of the object beforehand.</p>
<p class="indent">There is a very important gotcha to using <span class="codesample">for-in</span> loops on objects. Depending on the browser, and also on certain special conditions, sometimes the elements that appear in the <span class="codesample">for-in</span> loop enumeration may not be what would be expected, as the loop may not only include the methods and properties that you put on the object, but built-in system ones that are of no interest to the script. If this is of concern, we can add a simple check to ensure the property is directly found in the object, rather than inherited:</p>
<p class="image"><img alt="image" src="f0189-04.jpg"/></p>
<p class="indenttop">Another important thing to note about <span class="codesample">for-in</span> loops is that they should generally be avoided on <span class="codesample">Array</span> objects and only used with <span class="codesample">Object</span> objects. The numeric indices of an array have the strong connotation that they should be enumerated in correct numeric order. However, <span class="codesample">for-in</span> loops do not guarantee any particular order of enumeration, so iterating over an array may produce unexpected results. In addition, a <span class="codesample">for-in loop</span> on a sparse array (an array with some elements set and some not) will enumerate only set indices and skip over unset ones, and this likely will also produce unexpected results.</p>
<p class="indent"><a id="page_190"/>The most common usage for object enumeration is debugging, but there are certainly other valid use-cases, such as traversing a deeply nested object structure searching for a particular value.</p>
<h6 class="h6"><strong>Using with</strong></h6>
<p class="noindent">Another object-related operator is <span class="codesample">with</span>:</p>
<p class="image"><img alt="image" src="f0190-01.jpg"/></p>
<p class="indent">Using <span class="codesample">with</span> lets you reference properties of an object without explicitly specifying the object itself. When you use an identifier within the statement or block associated with a <span class="codesample">with</span> statement, the interpreter checks to see if the object has a property of that name. If it does, the interpreter uses it. For example:</p>
<p class="image"><img alt="image" src="f0190-02.jpg"/></p>
<p class="noindent">In this case, <span class="codesample">with</span> lets you access <span class="codesample"><em>obj.prop_1</em></span> and <span class="codesample"><em>obj.prop_2</em></span> with less typing. In fact, the primary use of <span class="codesample">with</span> statements is to reduce the clutter in your scripts.</p>
<p class="indent">Usage of <span class="codesample">with</span> comes with some dangerous caveats, and many JavaScript pundits, including the authors, suggest it should be avoided. The most glaring caveat for <span class="codesample">with</span> is illustrated here:</p>
<p class="image"><img alt="image" src="f0190-03.jpg"/></p>
<p class="noindent">Here, we see that <span class="codesample"><em>prop_3</em></span> is not created on <span class="codesample"><em>obj</em></span>, as one might expect, but instead is leaked into the containing scope outside of the <span class="codesample">with</span> statement and thus becomes a global variable—in other words, a property of the <span class="codesample">Window</span> object. We advise that you avoid using <span class="codesample">with</span> statements, if at all possible, especially as it is not valid in ECMAScript 5 strict mode; but if you do, use them with caution.</p>
<hr/>
<p class="note"><a id="page_191"/><strong>NOTE</strong> Like the <span class="codesample">eval()</span> method, the <span class="codesample">with</span> statement should throw an error when “<span class="codesample">use strict</span>” is employed under ECMAScript 5.</p>
<h5 class="h5"><a id="ch06lev2sec4"/><strong>Objects Are Reference Types</strong></h5>
<p class="noindent">All JavaScript data types can be categorized as either primitive or reference types. These two types correspond to the primitive and composite types discussed in <a class="nounder" href="ch03.html#ch03">Chapter 3</a>. <em>Primitive types</em> are the primitive data types: <span class="codesample">Number, String, Boolean, undefined</span>, and <span class="codesample">null</span>. You can think of primitive data as stored directly in the variable itself. <em>Reference types</em> are objects, and in JavaScript these types include <span class="codesample">Object, Array</span>, and <span class="codesample">Function</span>. Because these types can hold very large amounts of heterogeneous data, a variable containing a reference type does not contain its actual value. It contains a <em>reference</em> to a place in memory that contains the actual data.</p>
<p class="indent">This distinction will be transparent to you the majority of the time, but there are some situations when you need to pay particular attention to the implications of these types. The first is when you create two or more references to the same object. Consider the following example with primitive types:</p>
<p class="image"><img alt="image" src="f0191-01.jpg"/></p>
<p class="noindent">This code behaves as you would expect. Because <span class="codesample"><em>x</em></span> has a primitive type (<span class="codesample">Number</span>), the value stored in it (<span class="codesample">10</span>) is assigned to <span class="codesample">y</span> on the second line. Changing the value of <span class="codesample"><em>x</em></span> has no effect on <span class="codesample"><em>y</em></span> because <span class="codesample"><em>y</em></span> received a copy of <span class="codesample"><em>x</em></span>’s value.</p>
<p class="indent">Now consider similar code using a reference type:</p>
<p class="image"><img alt="image" src="f0191-02.jpg"/></p>
<p class="noindent">Because arrays are reference types, the second line copies the reference to <span class="codesample"><em>x</em></span>’s data into <span class="codesample"><em>y</em></span>. Now both <span class="codesample"><em>x</em></span> and <span class="codesample"><em>y</em></span> refer to the same data, so changing the value of this data using either variable is naturally visible to both <span class="codesample"><em>x</em></span> and <span class="codesample"><em>y</em></span>. In case you want to make a copy of the data instead of a copy by reference, it would be necessary to create a new array and set the contents to the contents of the first array. It is possible to do this either looping through the original array or manipulating some <span class="codesample">Array</span> methods to achieve this. For example, the <span class="codesample">splice</span> method can manipulate an array by adding and removing entries and returning a copy. However, if no parameters are sent to add or delete, it just returns a copy:</p>
<p class="image"><img alt="image" src="f0191-03.jpg"/></p>
<h6 class="h6"><a id="page_192"/><strong>Passing Objects to Functions</strong></h6>
<p class="noindent">Another situation in which you need to pay careful attention to reference types is when passing them as arguments to functions. Recall from <a class="nounder" href="ch05.html#ch05">Chapter 5</a> that arguments to functions are passed by value. Because reference types hold a reference to their actual data, function arguments receive a copy of the reference to the data, and can, therefore, modify the original data. This effect is shown in the following example, which passes two values—a primitive and a reference type—to a function that modifies their data:</p>
<p class="image"><img alt="image" src="f0192-01.jpg"/></p>
<p class="image"><img alt="image" src="f0192-02.jpg"/></p>
<p class="noindent">The result is shown in <a class="nounder" href="ch06.html#fig6-1">Figure 6-1</a>. Notice how the value of the reference type changed, but the value of the primitive type did not.</p>
<hr/>
<p class="online"><strong>ONLINE</strong> <a class="nounder" href="http://www.javascriptref.com/3ed/ch6/parameterpassing.html">http://javascriptref.com/3ed/ch6/parameterpassing.html</a></p>
<p class="image1"><a id="page_193"/><a id="fig6-1"/><img alt="image" src="f0193-01.jpg"/></p>
<p class="figcap"><strong>Figure 6-1</strong> Parameter passing with primitive and reference types</p>
<p class="indent">While references can easily be assigned to create an alias to an object, as seen in the previous example, references are weak in that they can just as easily be reassigned or unassigned. In contrast to some other languages, in JavaScript you cannot affect other references to an object with just a single reference to that object. This point is illustrated here:</p>
<p class="image"><img alt="image" src="f0193-02.jpg"/></p>
<p class="noindent">From inside the <span class="codesample"><em>doSomething()</em></span> function, you cannot destroy the object that you were passed a shared reference to (as parameter <span class="codesample"><em>ref</em></span>); you can only modify the shared object’s properties with that reference. Similarly, with a reference (<span class="codesample"><em>obj2</em></span>) to the shared object, you can add a property, but reassigning <span class="codesample"><em>obj2</em></span> to point to another object has no effect on the original object still referenced by <span class="codesample"><em>obj1</em></span>.</p>
<p class="indent"><a id="page_194"/>The key takeaway here is that when you use a de-reference and add, delete, or change properties on that object, you affect the same shared object that any other references point to. However, if you take a single variable that is only one of many references to some shared object, and unset only that variable, or assign it some other value/reference, you do not affect the shared object nor any other references to it.</p>
<h6 class="h6"><strong>Comparing Objects</strong></h6>
<p class="noindent">Another situation where you need to be careful with reference types (objects) is when comparing them. When you use the equality (<span class="codesample">==</span>) comparison operator, the interpreter compares the value in the given variables. For primitive types, this means comparing the actual data:</p>
<p class="image"><img alt="image" src="f0194-01.jpg"/></p>
<p class="indent">For reference types, variables hold a reference to the data, not the data itself. So using the equality operator compares <em>references</em>, and not the objects to which they refer. In other words, the <span class="codesample">==</span> operator checks not whether the two variables refer to equivalent objects, but <em>whether the two variables refer to the exact same object</em>. To illustrate:</p>
<p class="image"><img alt="image" src="f0194-02.jpg"/></p>
<p class="noindent">Even though the objects to which <span class="codesample"><em>str1</em></span> and <span class="codesample"><em>str2</em></span> refer are equivalent, they aren’t the same object, so the result of the comparison is <span class="codesample">false</span>. If they are just references, like so:</p>
<p class="image"><img alt="image" src="f0194-03.jpg"/></p>
<p class="noindent">they will compare truthfully. Use of the strict comparison (<span class="codesample">===</span>) will, of course, produce the same result, as they are the same value and type; indeed, they are the same object!</p>
<p class="indent">However, this still begs the question, how do you compare two different objects to see if they are the same value? In the case of the primitives as objects, we can cast them back to strings:</p>
<p class="image"><img alt="image" src="f0194-04.jpg"/></p>
<p class="noindent">We also may rely on the <span class="codesample">valueOf()</span> method on the <span class="codesample">String</span> object, to access its underlying primitive value:</p>
<p class="image"><img alt="image" src="f0194-05.jpg"/></p>
<p class="noindent">However, these examples do not address generic objects. Consider these two generic objects:</p>
<p class="image"><img alt="image" src="f0194-06.jpg"/></p>
<p class="noindent">Given what we have previously shown, there is no simple way to compare them:</p>
<p class="image"><a id="page_195"/><img alt="image" src="f0195-01.jpg"/></p>
<p class="noindent">You could write a function that would enumerate the properties of the object and then compare them one at a time. A naive approach is shown here:</p>
<p class="image"><img alt="image" src="f0195-02.jpg"/></p>
<p class="noindent">Unfortunately, this approach isn’t quite right, as it doesn’t deal with nesting and more complex objects. For example:</p>
<p class="image"><img alt="image" src="f0195-03.jpg"/></p>
<p class="noindent">To compare object values, you would have to inspect each property and address nesting and various type details recursively in case objects are nested:</p>
<p class="image"><img alt="image" src="f0195-04.jpg"/></p>
<p class="image"><img alt="image" src="f0195-05.jpg"/></p>
<p class="noindent"><a id="page_196"/>Fortunately for readers, object comparison is commonly found in many JavaScript frameworks; but if you ever desire to do it yourself, now you know how.</p>
<hr/>
<p class="note"><strong>NOTE</strong> A shortcut method to advanced object comparisons may be to “stringify” the two objects into JSON format and then compare the strings.</p>
<h5 class="h5"><a id="ch06lev2sec5"/><strong>Common Properties and Methods</strong></h5>
<p class="noindent">All JavaScript objects have the common properties and methods listed in <a class="nounder" href="ch06.html#tab6-2">Table 6-2</a>. With advanced JavaScript programming, many of these properties and methods are proving useful.</p>
<p class="tabcap"><a id="tab6-2"/><strong>Table 6-2</strong> Properties and Methods Common to All Objects</p>
<p class="image"><img alt="image" src="t0196-01.jpg"/></p>
<p class="indent">Two common methods you should become familiar with are <span class="codesample">toString()</span>, which converts the object to a primitive string, and <span class="codesample">valueOf()</span>, which converts the object to the most appropriate primitive type. In most cases (except, for instance, equality comparison, as we saw above), these methods are automatically invoked when an object is used in a context that requires one or the other. For example:</p>
<p class="image"><img alt="image" src="f0196-01.jpg"/></p>
<p class="noindent">Since <span class="codesample">alert()</span> requires a string argument, the interpreter calls the <span class="codesample">Date.toString()</span> method behind the scenes. The <span class="codesample">Date</span> object knows how to turn itself into a string, so the result is shown in <a class="nounder" href="ch06.html#fig6-2">Figure 6-2</a>.</p>
<p class="image1"><a id="fig6-2"/><img alt="image" src="f0197-01.jpg"/></p>
<p class="figcap"><strong>Figure 6-2</strong> Example of Date.toString() method</p>
<p class="indent"><a id="page_197"/>The <span class="codesample">valueOf()</span> method is similar. Since it doesn’t make any sense to make a relational comparison of references, relational comparison operators require two primitive types to operate on. So when you use one of these operators with objects, the objects are converted into their appropriate primitive forms:</p>
<p class="image"><img alt="image" src="f0197-02.jpg"/></p>
<p class="noindent">The comparison causes the <span class="codesample">valueOf()</span> method of the two objects to be called so they may be compared.</p>
<p class="indent">The <span class="codesample">valueOf()</span> method gives us a way to compare two objects for equality:</p>
<p class="image"><img alt="image" src="f0197-03.jpg"/></p>
<p class="indent">You typically won’t have to worry about manually converting values in this fashion. However, knowing that methods such as <span class="codesample">valueOf()</span> and <span class="codesample">toString()</span> exist can be helpful should you find yourself with undesirable type-conversion or comparison behaviors, and especially if you’re creating your own user-defined objects.</p>
<p class="indent">Now that we’ve covered the fundamentals of how objects behave and how you can create and manipulate user-defined objects, it’s time to explore JavaScript’s object-oriented features. These features enable you to structure your scripts in a mature fashion similar to more mainstream application development languages such Java and C++. JavaScript’s object-oriented features aren’t the same as these languages, but regardless of differences of approach you should eventually find that what JavaScript has to offer is also well suited to the kinds of tasks required when writing large scripts or building Web-based applications, if you avoid trying to force JavaScript into patterns you bring from class-based languages.</p>
<h4 class="h4"><a id="ch06lev1sec3"/><strong>Object-Oriented JavaScript</strong></h4>
<p class="noindent">Before jumping into the specifics of using JavaScript’s object-oriented features, let’s first understand why an object-oriented approach might be useful. The primary reason is that it allows you to write cleaner scripts—that is, scripts in which data and the code that operates on it are encapsulated in one place. Consider the <span class="codesample">Document</span> object. It encapsulates the currently displayed document and presents an interface by which you can examine and manipulate the document in part or as a whole. Can you imagine how confusing document manipulation would be if all of the document-related data and methods were just sitting in <a id="page_198"/>the global namespace (that is, not accessed as <span class="codesample">document.<em>something</em></span> but just as <span class="codesample"><em>something</em></span>)? What would happen if <em>all</em> of JavaScript’s functionality were so exposed? Even simple programming tasks would be a nightmare of namespace collisions and endless hunting for the right function or variable. The language would be essentially unusable. This is an extreme example, but it illustrates the point. Even smaller-scale abstractions are often best implemented as objects.</p>
<p class="indent">However, we haven’t really said why it is desirable to have any more advanced object-oriented features in JavaScript than those we’ve already seen (user-defined <span class="codesample">Objects</span> with programmer-settable instance properties). The reason is that doing anything but small-scale object-oriented programming with the techniques covered so far would be incredibly laborious. For objects of the same type, you’d be forced to set the same properties and methods of each instance manually. What would be more efficient would be to have a way to specify those properties and methods common to all objects of a certain type once, and have every instance of that type “inherit” the common data and logic. This is the key motivator of JavaScript’s object-oriented features.</p>
<h5 class="h5"><a id="ch06lev2sec6"/><strong>Prototype-Based Objects</strong></h5>
<p class="noindent">Java and C++ are <em>class-based</em> object-oriented languages. An object’s properties are defined by its <em>class</em> —a description of the code and data that each object of that class contains. In these languages, a class is defined at compile time—that is, by the source code the programmer writes. You can’t add new properties and methods to a class at runtime, and a program can’t create new data types while it’s running.</p>
<p class="indent">Because JavaScript is interpreted (and therefore has no visible distinction between compile time and runtime), a more dynamic approach is called for. JavaScript doesn’t have a formal notion of a class; instead, you create new types of objects on the fly, and you can modify the properties of existing objects whenever you please.</p>
<p class="indent">JavaScript is a <em>prototype-based</em> object-oriented language, meaning that every object has a prototype, an object from which it inherits properties and methods. When a property of an object is accessed or a method is invoked, the interpreter first checks to see if the object has an instance property of the same name. If so, the instance property is used. If not, the interpreter checks the object’s prototype for the appropriate property. In this way, the properties and methods common to all objects of that type can be encapsulated in the prototype, and each object can have instance properties representing the specific data for that object. For example, the <span class="codesample">Date</span> prototype should contain the method that turns the object into a string because the way it does so is the same for all <span class="codesample">Date</span> objects. However, each individual <span class="codesample">Date</span> should have its own data indicating the specific date and time it represents.</p>
<p class="indent">The only further conceptual aspect to the way objects work in JavaScript is that the prototype relationship is recursive. That is, an object’s prototype is also an object and can, therefore, itself have a prototype, and so on. This means that if a property being accessed isn’t found as an instance property of an object or as a property of its prototype, the interpreter “follows” the prototype chain to the prototype’s prototype and searches for it there. If it still hasn’t been found, the search continues “up” the prototype chain. You might ask, “Where does it end?” The answer is easy: at the generic <span class="codesample">Object</span>. <em>All</em> objects in JavaScript ultimately are “descendent” from a generic <span class="codesample">Object</span>, so it is here that the search stops. If the property isn’t found in the <span class="codesample">Object</span>, the value is <em>undefined</em> (or a runtime error is thrown, in the case of method invocation).</p>
<hr/>
<p class="note"><a id="page_199"/><strong>NOTE</strong> The fact that <span class="codesample">Object</span> is the “superclass” of all other objects explains why we said with confidence in <a class="nounder" href="ch06.html#tab6-2">Table 6-2</a> that the properties and methods listed there are present in every object: because these are exactly the properties and methods of a generic <span class="codesample">Object</span>!</p>
<p class="indent">Now that we’ve explained the theoretical basis for JavaScript’s object-oriented features, let’s see how it translates into implementation. If you’re feeling a bit lost at this point, that’s okay; we’ll reiterate the theory as we cover the concrete details.</p>
<h5 class="h5"><a id="ch06lev2sec7"/><strong>Constructors</strong></h5>
<p class="noindent">Object instances are created with <em>constructors</em>, which are basically special functions that prepare new instances of an object for use. Every constructor contains an object <em>prototype</em> that defines the code and data that each object instance has by default.</p>
<hr/>
<p class="note"><strong>NOTE</strong> Before delving any deeper, some commentary regarding nomenclature is appropriate. Because everything in JavaScript except primitive data and language constructs is an object, the term “object” is used quite often. It is important to differentiate between a type of object, such as the <span class="codesample">Array</span> or <span class="codesample">String</span> object, and an instance of an object, such as a particular variable containing a reference to an <span class="codesample">Array</span> or <span class="codesample">String</span>. A type of object is defined by a particular constructor. All instances created with that constructor are said to have the same “type” or “class” (to stretch the definition of class a bit). To keep things clear, remember that a constructor and its prototype define a type of object and that objects created with that constructor are instances of that type.</p>
<p class="indenttop">We’ve seen numerous examples of object creation; for example:</p>
<p class="image"><img alt="image" src="f0199-01.jpg"/></p>
<p class="noindent">This line invokes the constructor for <span class="codesample">String</span> objects, a function named <span class="codesample">String()</span>. JavaScript knows that this function is being used as a constructor because it is called in conjunction with the <span class="codesample">new</span> operator.</p>
<p class="indent">We can define our own constructor by defining a function:</p>
<p class="image"><img alt="image" src="f0199-02.jpg"/></p>
<p class="noindent">This function by itself does absolutely nothing. However, we can invoke it as a constructor just like we did for <span class="codesample">String()</span>:</p>
<p class="image"><img alt="image" src="f0199-03.jpg"/></p>
<p class="noindent">We have now created an instance of the <span class="codesample"><em>Robot</em></span> object. Obviously, this object is not particularly useful. More information about object construction is necessary before we proceed.</p>
<hr/>
<p class="note"><strong>NOTE</strong> Constructors don’t have to be named with an initial uppercase. However, doing so is preferable because it makes the distinction clear between a constructor (initial uppercase) that defines a type and an instance of a type (initial lowercase).</p>
<p class="indent"><a id="page_200"/>When a constructor is invoked, the interpreter allocates space for the new object and implicitly passes the new object to the function. The constructor can access the object being created using <span class="codesample">this</span>, a special keyword that holds a reference to the new object. The reason the interpreter makes <span class="codesample">this</span> available is so the constructor can manipulate the object it is creating easily. For example, it could be used to set a default value, so we can redefine our constructor to reflect this ability:</p>
<p class="image"><img alt="image" src="f0200-01.jpg"/></p>
<p class="noindent">This example adds an instance property <span class="codesample"><em>hasJetpack</em></span> to each new object it creates. After creating an object with this constructor, we can access the <span class="codesample"><em>hasJetpack</em></span> property as one would expect:</p>
<p class="image"><img alt="image" src="f0200-02.jpg"/></p>
<p class="indent">Since constructors are functions, you can pass arguments to constructors to specify initial values. We can modify our constructor again so that it takes an optional argument:</p>
<p class="image"><img alt="image" src="f0200-03.jpg"/></p>
<p class="noindent">Note that, in this example, we could have explicitly passed in a <span class="codesample">false</span> value when creating the <span class="codesample"><em>sidekick</em></span> instance. However, by passing in nothing, we implicitly have done so, since the parameter <span class="codesample"><em>needsToFly</em></span> would be <span class="codesample">undefined</span>. We use the double negation <span class="codesample">!(!<em>needsToFly</em>)</span> to coerce any non-Boolean value (such as <span class="codesample">undefined</span>) to a pure <span class="codesample">Boolean</span> value.</p>
<h6 class="h6"><strong>Objects and Primitive Values: Automatic Construction and Conversion</strong></h6>
<p class="noindent">We should take a moment to discuss the construction and conversion to native objects that happens in JavaScript. Most of the time, when working with primitive types we do not make them <span class="codesample">true</span> native objects:</p>
<p class="image"><img alt="image" src="f0200-04.jpg"/></p>
<p class="indent">However, while we did not create the city value with a <span class="codesample">new String()</span> constructor, we find that JavaScript often converts type primitives to and from their related objects under many circumstances. For example, the string primitive value may be automatically cast into a <span class="codesample">String</span> object if an attempt to access <span class="codesample">String</span> methods on that variable is made:</p>
<p class="image"><img alt="image" src="f0200-05.jpg"/></p>
<p class="noindent"><a id="page_201"/>This would even be <span class="codesample">true</span> on a string literal; for example:</p>
<p class="image"><img alt="image" src="f0201-01.jpg"/></p>
<p class="indent">Conversely, a proper <span class="codesample">String</span> object automatically will be coerced to a primitive string value for operations such as <span class="codesample">Boolean</span> comparison:</p>
<p class="image"><img alt="image" src="f0201-02.jpg"/></p>
<p class="indent">Under certain circumstances, some native object constructors have the special behavior that they will coerce an object to its primitive value if not called with the <span class="codesample">new</span> operator—that is, if they are called as functions instead of as constructors. This behavior is not consistent across all of the natives, so caution should be used with this approach. Usually, JavaScript will take care of implicit casting automatically, but in certain circumstances using a constructor in this way is effective for explicitly casting an object to a primitive value:</p>
<p class="image"><img alt="image" src="f0201-03.jpg"/></p>
<p class="indent">The <span class="codesample">Object()</span> constructor has even more special behavior built into it. If you pass a more specific native object type as the parameter to the <span class="codesample">Object()</span> constructor, it will actually type-detect and return the proper native object type, constructed automatically. For instance, <span class="codesample">new Object</span> (“<span class="codesample">foo</span>”) will result the same as if you called <span class="codesample">new String</span> (“<span class="codesample">foo</span>”). If this list of different ways to do roughly the same thing but with subtle details makes your head spin, consider focusing on the simple approach of a direct primitive declaration unless there is some overriding reason not to.</p>
<h5 class="h5"><a id="ch06lev2sec8"/><strong>Prototypes</strong></h5>
<p class="noindent">Besides properties, we also can add methods to the objects we create. One way to do so is to assign an instance variable an anonymous function inside of the constructor, just as we added an instance property. However, this is a waste of memory because each object created would have its own copy of the function. A better way to do this is to use the object’s prototype.</p>
<p class="indent">Every object has an internal prototype that gives it its structure. This internal prototype (also known as <span class="codesample">[[Prototype]]</span> in the ECMAScript specification) is a reference to an object describing the code and data that all objects of that same type will have in common.</p>
<p class="indent">The internal prototype of an object is not the same as the <span class="codesample">prototype</span> property of a function. Regular object instances do not have a <span class="codesample">prototype</span> property, only functions (technically, <span class="codesample">Function</span> objects) do. The <span class="codesample">prototype</span> property of a function will be used <em>as</em> the internal prototype for the new object when that function is called as a constructor (that is, with the <span class="codesample">new</span> keyword).</p>
<p class="indent">This point is very critical to understand and exceedingly easy to get confused, so let us repeat: only functions have a <span class="codesample">prototype</span> property, and that property is used by the function to create a new object when the function is called as a constructor.</p>
<p class="indent"><a id="page_202"/>We can populate the constructor’s prototype with the code and data we want all of our <span class="codesample">Robot</span> objects to possess. We modify our definition to the following:</p>
<p class="image"><img alt="image" src="f0202-01.jpg"/></p>
<p class="noindent">Several substantial changes have been made. First, we moved the <span class="codesample"><em>hasJetpack</em></span> property into the prototype and gave it the default value of <span class="codesample">false</span>. Second, we added a function <span class="codesample"><em>doAction()</em></span> to the prototype of the constructor. Every <span class="codesample"><em>Robot</em></span> object we create now has both properties:</p>
<p class="image"><img alt="image" src="f0202-02.jpg"/></p>
<p class="noindent">Here we begin to see the power of prototypes. We can access these two properties (<span class="codesample"><em>hasJetpack</em></span> and <span class="codesample"><em>doAction()</em></span>) through an instance of an object, even though they weren’t specifically set in the object. As we’ve stated, if a property is accessed and the object has no instance property of that name, the object’s prototype is checked, so the interpreter finds the properties even though they weren’t explicitly set. If we omit the argument to the <span class="codesample"><em>Robot()</em></span> constructor and then access the <span class="codesample"><em>hasJetpack</em></span> property of the object created, the interpreter finds the default value in the prototype. If we pass the constructor <span class="codesample">true</span>, then the default value in the prototype is overridden by the constructor adding an instance property called <span class="codesample"><em>hasJetpack</em></span> whose value is also <span class="codesample">true</span>.</p>
<p class="indent">Methods can refer to the object instance they are contained in using <span class="codesample">this</span>. We can redefine our class once again to reflect the new capability:</p>
<p class="image"><img alt="image" src="f0202-03.jpg"/></p>
<p class="noindent">We have added a new property to the prototype, <span class="codesample"><em>actionValue</em></span>. This property has a default value that can be overridden by passing a second argument to the constructor, which sets an instance property of the same name. The <span class="codesample">this.<em>actionValue</em></span> reference inside of the <span class="codesample"><em>doAction()</em></span> function illustrates an important point in prototype inheritance. If an instance property has been set, it will be found via <span class="codesample">this.<em>actionValue</em></span>. If not, <span class="codesample">this.<em>actionValue</em></span> will resolve to the inherited default value from the prototype. For example,</p>
<p class="image"><a id="page_203"/><img alt="image" src="f0203-01.jpg"/></p>
<p class="noindent">results in “ZAP!” being alerted rather than “Intruders beware.”</p>
<h6 class="h6"><strong>Dynamic Types, Extending Natives</strong></h6>
<p class="noindent">A very important aspect of the prototype is that it is <em>shared</em>. That is, there is only one copy of the prototype that all objects created with the same constructor use. An implication of this is that a change in the prototype will be visible to all objects that share it! This is why default values in the prototype are overridden by instance variables, and not changed directly. Changing them in the prototype would change the value for <em>all</em> objects sharing that prototype.</p>
<p class="indent">Since JavaScript is a dynamic language, we may find that modifying the prototypes of native objects is very useful, albeit a bit dangerous. Suppose you need to repeatedly extract the third character of strings. You can modify the prototype of the <span class="codesample">String</span> object so that all strings have a method of your definition:</p>
<p class="image"><img alt="image" src="f0203-02.jpg"/></p>
<p class="noindent">You can invoke this method as you would any other native <span class="codesample">String</span> method:</p>
<p class="image"><img alt="image" src="f0203-03.jpg"/></p>
<p class="indent">A very important note of warning should be stated here. The practice of extending the prototypes of native objects is both useful and dangerous. For example, it is commonly forbidden to extend the native <span class="codesample">Object</span> prototype (from which all other objects inherit), useful as that may sound, because doing so causes those properties/methods to be seen in <span class="codesample">for-in</span> loops that do not properly filter with <span class="codesample">hasOwnProperty()</span>.</p>
<p class="indent">The other, more important reason to avoid extending native object prototypes, even <span class="codesample">String</span>, is forward compatibility, either with the language itself or with other scripts. Let’s say you define a <span class="codesample">String</span> function called <span class="codesample">trim()</span>, whose job is to trim off whitespace from either side of the given string instance. Sounds harmless enough, right? However, future versions of JavaScript may include their own native implementation of such a function/method. In fact, ECMAScript 5 does, in fact, define a <span class="codesample">String.prototype.trim</span> function, which yours will eventually collide with. If you are going to extend the prototype of native objects, the best practice is to check for the existence of the property/method before defining it, like so:</p>
<p class="image"><img alt="image" src="f0203-04.jpg"/></p>
<p class="noindent">However, you should be aware that if you have other code in your application that relies on the specific way your implementation works, and someone uses your application in a browser that defines the native implementation, your other code may break or behave unexpectedly. This is especially <span class="codesample">true</span> if your custom method has one set of parameters and the final native implementation of the colliding function defines a different order or signature for those parameters. In this case, things are certain to break.</p>
<p class="indent"><a id="page_204"/>Of course, colliding with future versions of JavaScript is not the only danger. Collisions between different code bases are all too common. If two different pieces of code try to define the same extension to a native prototype but their implementations or parameter lists are different, the same breakage is almost certain to occur.</p>
<hr/>
<p class="note"><strong>NOTE</strong> There is a technique for extending native object prototypes in JavaScript dubbed “sandboxed natives.” It is not a standard method, but some libraries have attempted to use it despite the complexity of cross-browser concerns. Interested readers should research the current attitude about extending native objects and the currently recommended approach before attempting their own changes.</p>
<h5 class="h5"><a id="ch06lev2sec9"/><strong>Class Properties</strong></h5>
<p class="noindent">In addition to instance properties and properties of prototypes, JavaScript allows you to define <em>class properties</em> (also known as <em>static properties</em>), which are properties of the type, rather than properties of a particular object instance. An example of a class property is <span class="codesample">Number.MAX_VALUE</span>. This property is a type-wide constant and, therefore, is more logically located in the class (constructor) rather than in individual <span class="codesample">Number</span> objects. But how are class properties implemented?</p>
<p class="indent">Because constructors are functions and functions are objects, you can add properties to constructors. Class properties are added this way. Although doing so technically adds an instance property to a type’s constructor, we’ll still call it a class variable. Continuing our example,</p>
<p class="image"><img alt="image" src="f0204-01.jpg"/></p>
<p class="noindent">defines a class property of the <span class="codesample"><em>Robot</em></span> object by adding an instance variable to the constructor. It is important to remember that static properties exist in only one place, as members of constructors. They are, therefore, accessed through the constructor rather than through an instance of the object.</p>
<p class="indent">As previously explained, static properties typically hold data or code that does not depend on the contents of any particular instance. The <span class="codesample">toLowerCase()</span> method of the <span class="codesample">String</span> object could not be a static method because the string it returns depends on the object on which it was invoked. On the other hand, the <span class="codesample">PI</span> property of the <span class="codesample">Math</span> object (<span class="codesample">Math.PI</span>) and the <span class="codesample">parse()</span> method of the <span class="codesample">String</span> object (<span class="codesample">String.parse()</span>) are perfect candidates because they do not depend on the value of any particular instance. You can see from the way they are accessed that they are, in fact, static properties. The <span class="codesample"><em>isMetallic</em></span> property we just defined is accessed similarly, as <span class="codesample"><em>Robot.isMetallic</em></span>.</p>
<p class="indent">It is also sometimes useful when defining object types to mirror instance-bound methods as static utility functions on the constructor. For instance, <span class="codesample">String.prototype.trim()</span> is the string instance method that operates on the instance it is called from. However, a static utility function such as <span class="codesample">String.trim()</span> could be defined that takes as its only parameter the string instance it should operate on:</p>
<p class="image"><img alt="image" src="f0204-02.jpg"/></p>
<p class="noindent"><a id="page_205"/>Of course, the same caution with extending native object prototypes should be exercised in defining static extensions to the native constructors. In general, this technique will be more useful with user-defined types than with natives.</p>
<p class="indent">Another interesting use of a class property is as a counter. If you want to keep track of the number of <span class="codesample"><em>Robot</em></span> objects created, it is possible to do so with the class property:</p>
<p class="image"><img alt="image" src="f0205-01.jpg"/></p>
<h5 class="h5"><a id="ch06lev2sec10"/><strong>Inheritance via the Prototype Chain</strong></h5>
<p class="noindent">Inheritance in JavaScript is achieved using prototypes. It is clear that instances of a particular object “inherit” the code and data present in the constructor’s <span class="codesample">prototype</span> property, but what we haven’t really seen so far is that it is also possible to derive a new object type from a type that already exists. Instances of the new type inherit all the properties of their own type, in addition to any properties embodied in their parent.</p>
<p class="indent">As an example, we can define a new object type that inherits all the capabilities of our <span class="codesample">Robot</span> object by “chaining” prototypes. At first glance, it would seem that all we need to do to create a child type is to set its <span class="codesample">prototype</span> property to that of the parent’s <span class="codesample">prototype</span> property, and the child instances will have automatically inherited all of the parent’s behavior. This might look like this:</p>
<p class="image"><img alt="image" src="f0205-02.jpg"/></p>
<p class="noindent">As you can see, there is a somewhat confusing and probably unintended side effect from directly copying the prototype from <span class="codesample"><em>Robot</em></span> into <span class="codesample"><em>UltraRobot</em></span> as a means of inheritance. Inheritance does, in fact, occur to grant “color” as a property from the parent <span class="codesample"><em>Robot</em></span> to the child <span class="codesample"><em>UltraRobot</em></span>. However, a weird sort of reverse inheritance also occurs in that the parent <span class="codesample"><em>Robot</em></span> now gets a <span class="codesample"><em>feature</em></span> property, because the child type <span class="codesample"><em>UltraRobot</em></span> defines <span class="codesample"><em>feature</em></span> on its <span class="codesample">prototype</span> property, which in this example happens to be a shared <span class="codesample">prototype</span> reference between the two object types.</p>
<p class="indent"><a id="page_206"/>Since this two-way inheritance is both confusing and potentially unwanted, there’s a preferred alternate pattern for inheriting via prototype, by creating an instance of the parent to set as the child type’s <span class="codesample">prototype</span> property. By using an object instance for the <span class="codesample">prototype</span> property instead of just another <span class="codesample">prototype</span> property reference, we break the awkward child-to-parent inheritance of the previous example:</p>
<p class="image"><img alt="image" src="f0206-01.jpg"/></p>
<p class="noindent">This pattern is often called “differential inheritance” because an <span class="codesample"><em>UltraRobot</em></span> instance contains only properties that are “different” from the inherited template (prototype) for the instance. The only new concept in this example is setting <span class="codesample"><em>UltraRobot</em></span>’s prototype to a new instance of a <span class="codesample">Robot</span> object. Because of the way properties are resolved via prototypes, <span class="codesample"><em>UltraRobot</em></span> objects will “contain” all the properties of the <span class="codesample"><em>UltraRobot</em></span> object as well as those of <span class="codesample"><em>Robot</em></span>.</p>
<p class="indent">The way the interpreter resolves property access in this example is analogous to the resolution scheme previously discussed. The object’s instance properties are first checked for a match; then, if none is found, its prototype (<span class="codesample"><em>UltraRobot</em></span>) is checked. If no match is found in the prototype, the parent prototype (<span class="codesample"><em>Robot</em></span>) is checked, and the process repeats recursively finally to the all-encompassing <span class="codesample">Object</span> object.</p>
<h6 class="h6"><strong>The constructor Property and instanceof Operator</strong></h6>
<p class="noindent">Every object instance is created by a constructor function, and, in turn, every new object instance has an initial reference to its original constructor function by way of the <span class="codesample">constructor</span> property. For instance:</p>
<p class="image"><img alt="image" src="f0206-02.jpg"/></p>
<hr/>
<p class="note"><strong>NOTE</strong> The reason a new object instance can initially resolve a <span class="codesample">constructor</span> property is because the object is inheriting that property from its own internal prototype. There is a somewhat confusing circular reference of sorts implied here: a constructor function has a <span class="codesample">prototype</span> property, and that <span class="codesample">prototype</span> property itself has a <span class="codesample">constructor</span> property, which points back to the constructor function.</p>
<p class="indenttop">Generally, the most practical use for examining the <span class="codesample">constructor</span> property is to determine if an object instance is of a certain type. For instance:</p>
<p class="image"><img alt="image" src="f0206-03.jpg"/></p>
<p class="noindent"><a id="page_207"/>This is similar to, although not the same as, using the <span class="codesample">instanceof</span> operator. The difference is subtle, though. The <span class="codesample">instanceof</span> operator will recursively check the entire internal prototype chain (meaning all the ancestor types), whereas the <span class="codesample">constructor</span> check as shown will only check the immediate object instance’s property. This ancestral checking is often very useful in inherited programming patterns with many layers of inheritance:</p>
<p class="image"><img alt="image" src="f0207-01.jpg"/></p>
<p class="noindent">The other important difference we see here, which makes <span class="codesample">instanceof</span> generally more reliable, is that the <span class="codesample">constructor</span> property is mutable, meaning it can be assigned to an entirely different value at any time, intentionally or not. This can be an advantage or a curse, depending on the situation. Also, it should be noted that <span class="codesample">instanceof</span> is unaffected by assignments of the <span class="codesample">constructor</span> property, and instead checks the internal prototype references for an object. The internal prototype is more predictable (and predictably mutable) than the <span class="codesample">constructor</span> property, which we’ll explore in the next section.</p>
<p class="indent">However, before we get to that, there is one case where setting the <span class="codesample">constructor</span> property can be useful. Consider this code:</p>
<p class="image"><img alt="image" src="f0207-02.jpg"/></p>
<p class="noindent">As you can see, our “differential inheritance” pattern of setting the child type constructor’s <span class="codesample">prototype</span> property to be a new instance of the parent type has the unfortunate side effect of setting the <span class="codesample">constructor</span> property for our new object instance to the parent type constructor function <span class="codesample"><em>Robot</em></span>, rather than to the child type constructor function <span class="codesample"><em>UltraRobot</em></span>, as we asked for. This mismatch can easily be fixed, like so:</p>
<p class="image"><img alt="image" src="f0207-03.jpg"/></p>
<p class="indent"><a id="page_208"/>As we’ll see in the next section, the internal prototype, which is much more powerful, is exposed in some JavaScript implementations, which means that, in some cases, you can alter the behavior of the <span class="codesample">instanceof</span> operator against an object instance by rewiring the internal prototype chain of the object.</p>
<h6 class="h6"><strong>__proto__, getPrototypeOf( )</strong></h6>
<p class="noindent">We’ve talked a lot so far about how an object instance always has an internal prototype that conceptually holds the blueprints for how instances of that object type default to behaving, but how can we examine that internal prototype?</p>
<p class="indent">Recall that an object instance does not have a <span class="codesample">prototype</span> property, only a <span class="codesample">constructor</span> property. Assuming that the <span class="codesample">constructor</span> property has not been altered for an instance, we can access an object’s internal prototype blueprints via <span class="codesample">obj.constructor.prototype</span>. However, we’ve seen that the constructor can be unreliable. Under certain circumstances, it doesn’t get set correctly, and under other circumstances it is intentionally changed.</p>
<p class="indent">Many current implementations of JavaScript, including most modern browsers except currently the IE family, implement a <span class="codesample">__proto__</span> property on an object instance as a more reliable way to access this internal prototype. Because of the lack of full cross-browser support, use of <span class="codesample">__proto__</span> should be done carefully and with proper capability detection, as we’ve seen in previous parts of this chapter.</p>
<p class="indent">In general (for supporting browsers) this code would work:</p>
<p class="image"><img alt="image" src="f0208-01.jpg"/></p>
<p class="noindent">As usual, there’s an important subtlety to catch here. An object’s <span class="codesample">__proto__</span> property is a reference to the same shared object that the <span class="codesample">prototype</span> property of its original constructor points to. As with all object references, if you make changes <em>on</em> either reference, the changes will be shared, but if you make changes <em>to</em> either reference (reassigning elsewhere), this sharing will be broken.</p>
<p class="indent">The <span class="codesample">__proto__</span> property is powerful and useful, and it shows the direct link between an object instance and its type. It is important to note that, because <span class="codesample">__proto__</span> is a mutable property, when it is changed it live-rewires an existing object instance’s behavior. Having the ability to set the <span class="codesample">__proto__</span> reference to a different object on the fly is a much more powerful (and potentially dangerous!) capability than just being able to access the constructor’s <span class="codesample">prototype</span> property.</p>
<p class="indent">To help sort things out beginning with JavaScript implementations of ECMAScript 5, a static helper function <span class="codesample">Object.getPrototypeOf()</span> has been added. This function adds the ability for you to access the same internal prototype property that <span class="codesample">__proto__</span> references. You are somewhat limited in that, with this function interface, you cannot reassign an object instance’s internal prototype (as you can with <span class="codesample">__proto__</span> directly), but at least you can modify anything about the existing internal prototype.</p>
<h6 class="h6"><a id="page_209"/><strong>Object.create( )</strong></h6>
<p class="noindent">We’ve seen now several examples of how to manually create an object and extend another object by inheriting its prototype. ECMAScript 5 has defined a very common factory pattern for this construction and inheritance, called <span class="codesample">Object.create()</span>. You simply pass in the object to inherit from, and you get back a new object all properly wired up and ready to go. Notice that you do not need to use the <span class="codesample">new</span> operator with <span class="codesample">Object.create()</span> calls:</p>
<p class="image"><img alt="image" src="f0209-01.jpg"/></p>
<p class="noindent">The object you pass to <span class="codesample">Object.create()</span> is used as the prototype for the new object. In the preceding example, the object instance <span class="codesample"><em>a</em></span> is used as the template for the new <span class="codesample"><em>b</em></span> object, but an intermediate step is hidden from the programmer. There’s an implied constructor function, which has its <span class="codesample">prototype</span> property set to the object <span class="codesample"><em>a</em></span>, and then that constructor function is used to create the new <span class="codesample"><em>b</em></span> object.</p>
<p class="indent">To reinforce what we explained earlier, let’s look at what implicitly happens when you make the <span class="codesample"><em>b.phrase</em></span> assignment. When <span class="codesample"><em>b</em></span> is first created, it has a prototype-inherited property called <span class="codesample"><em>phrase</em></span>, meaning that the property is <em>not</em> on the instance (<span class="codesample"><em>b.phrase</em></span>), but actually on the prototype (<span class="codesample"><em>b.prototype.phrase</em></span>). If you were to read the value of <span class="codesample"><em>b.phrase</em></span> at that point, JavaScript would implicitly look it up, find it on the prototype, and return it to you. However, when you make the assignment of a new value to <span class="codesample"><em>b.phrase</em></span>, you haven’t affected the inherited <span class="codesample"><em>b.prototype.phrase</em></span> but have instead set (overridden) an instance property <span class="codesample"><em>b.phrase</em></span> that takes precedence over the inherited <span class="codesample"><em>b.prototype.phrase</em></span> on future property accesses.</p>
<p class="indent">Clearly, <span class="codesample">Object.create()</span> is a very useful utility for extending objects and hiding some of the messy details. However, it was not defined until ECMAScript 5, so many commonly used browsers don’t have it yet. For now, we can define it manually and mimic the behavior, as shown here:</p>
<p class="image"><img alt="image" src="f0209-02.jpg"/></p>
<p class="noindent">To explain what’s happening here, first you need to understand that a <span class="codesample">prototype</span> property can only be set on a function object (in this example, <span class="codesample"><em>F()</em></span>), and then it’s only used when the function is called as a constructor. So, we define <span class="codesample"><em>F()</em></span> internally as an implicit function we can use as a constructor. Then we set its <span class="codesample">prototype</span> property to the passed in object <span class="codesample"><em>o</em></span> that we want to inherit from. Lastly, we call the constructor <span class="codesample"><em>F()</em></span> with <span class="codesample">new</span>, which creates an object whose internal prototype is now <span class="codesample"><em>o</em></span>, and we return the result.</p>
<p class="indent"><a id="page_210"/>Recall from the previous section that an object’s <span class="codesample">constructor</span> property points to the function that was used to construct it. When <span class="codesample">Object.create()</span> is used to spawn a child object from a parent object, the <span class="codesample">constructor</span> property is automatically set when <span class="codesample">prototype</span> is set on the constructor function <span class="codesample"><em>F()</em></span>. So the child object’s <span class="codesample">constructor</span> property points back to the same function that the parent object’s <span class="codesample">constructor</span> property points to. <span class="codesample">Object.create()</span> is passed a parent object <em>o</em> with no direct constructor to use to create the child. So in the native implementation, the default behavior is to borrow the constructor from the original parent object <span class="codesample"><em>o</em></span> for the task. For our manual implementation, we use an internal surrogate constructor function, but the end result looks the same to the outside world.</p>
<p class="indent">We should point out some subtle details. For example, by appearances, the same constructor function produces both the parent and the child because the child’s <span class="codesample">constructor</span> property ends up exactly the same as the parent’s <span class="codesample">constructor</span> property. Also, note that with the <span class="codesample">Object.create()</span> pattern, which is essentially constructor-less object inheritance, there is no suitable child “type” for you to use in conjunction with the <span class="codesample">instanceof</span> operator, as shown in a previous section. However, the <span class="codesample">instanceof</span> check can be made if you have a reference to the constructor used for the object; in this case, we saw that it is the same as the parent’s constructor:</p>
<p class="image"><img alt="image" src="f0210-01.jpg"/></p>
<p class="noindent">There is no child type <span class="codesample"><em>B</em></span> for <span class="codesample"><em>b</em></span> to be an instance of, so <span class="codesample"><em>b</em></span> is instead an instance of <span class="codesample"><em>A</em></span>. Similarly, <span class="codesample">b.constructor</span> points at <span class="codesample">A</span>.</p>
<h5 class="h5"><a id="ch06lev2sec11"/><strong>Overriding Default Methods and Properties</strong></h5>
<p class="noindent">It is often useful to provide specific methods or properties for user-defined objects that override the default behavior of the parent. For example, the default value of <span class="codesample">toString()</span> for objects is [ <span class="codesample">object Object</span>]. You might wish to override this behavior by defining a new, more appropriate <span class="codesample">toString()</span> method for your types:</p>
<p class="image"><img alt="image" src="f0210-02.jpg"/></p>
<h4 class="h4"><a id="ch06lev1sec4"/><strong>ECMAScript 5 Object-Related Changes</strong></h4>
<p class="noindent">As discussed in <a class="nounder" href="ch02.html#ch02">Chapter 2</a>, ECMAScript 5 has added several exciting new features specifically related to objects and their properties. For the most part, these features are exposing to programmers details that used to be intrinsic to the JavaScript engine and hidden from the programmer’s control. All of the new functions described in this section are static functions on the <span class="codesample">Object</span> object. There are no additional automatic methods on object instances (that is, <span class="codesample">Object.prototype.fn</span>).</p>
<p class="indent"><a id="page_211"/>The most important concept to understand is that all variables and properties have an underlying set of “attributes” associated with them. These attributes govern how the JavaScript engine interacts with, tracks, and manipulates their values. Moreover, these attributes dictate how a programmer can interact with them. For instance, a variable or property has an attribute called <span class="codesample">writeable</span> that controls whether or not its value can be changed. The <span class="codesample">configurable</span> attribute controls whether the variable’s attributes can be modified. The <span class="codesample">enumerable</span> attribute controls whether a property should appear in a <span class="codesample">for-in</span> loop iteration. Be careful with <span class="codesample">configurable</span>: once it is set to <span class="codesample">false</span>, nothing about the attributes, including <span class="codesample">configurable</span> itself, can ever be changed again for that particular object property.</p>
<p class="indent">These attributes have default values, depending on how the variable or property is declared, but now a programmer can explicitly control them by specifying a <em>property descriptor</em> (an object whose keys are the named attributes as described above) as part of a new static helper function <span class="codesample">Object.defineProperty()</span>. For example:</p>
<p class="image"><img alt="image" src="f0211-01.jpg"/></p>
<p class="noindent">The converse of <span class="codesample">Object.defineProperty()</span> is <span class="codesample">Object.getOwnPropertyDescriptor()</span>. For example:</p>
<p class="image"><img alt="image" src="f0211-02.jpg"/></p>
<p class="noindent">You can also define multiple properties at once using <span class="codesample">Object.defineProperties()</span>, passing for the second argument an object with one or more property names and their property descriptors.</p>
<p class="image"><img alt="image" src="f0211-03.jpg"/></p>
<p class="noindent"><a id="page_212"/>An exciting new addition, which programmers from other languages may be familiar with, is the notion of property accessors (that is, getters and setters). Basically, they allow you to define a function that should be run whenever an object’s property is accessed, either to read (get) or write (set) it. For most normal properties, getters and setters would be overkill, but if you have a complex or abstract property that needs to hide logic from the outside programmer, an accessor may be the right option.</p>
<p class="indent">There are two ways to define a get or set function for a given property. One of them is through the <span class="codesample">Object.defineProperty()</span> function we’ve just seen, setting the “get” and “set” attributes appropriately, just as with <span class="codesample">writeable</span>, and so on.</p>
<p class="indent">The other way to define getters and setters is through a new language construct extension in the <span class="codesample">Object</span> literal syntax. Because this is a syntactic approach to definition rather than a programmatic one through <span class="codesample">Object.defineProperty()</span>, it’s important to note that older browsers will see this as a syntax error, for which there is no way to hide such syntax from the browser. As such, for code that needs to maintain backward compatibility, this approach should be avoided; a comparison of the two approaches is shown here:</p>
<p class="image"><img alt="image" src="f0212-01.jpg"/></p>
<p class="noindent">We’ve seen how properties have certain attributes that we can use to control the behavior of the property. Objects also have some properties that can be set.</p>
<p class="indent">First, an object has an extensible capability, which roughly controls whether the object can have properties added to it. This attribute defaults to <span class="codesample">true</span> for all objects and can be inspected with <span class="codesample">Object.isExtensible()</span>. The attribute can be set to <span class="codesample">false</span> by calling <span class="codesample">Object.preventExtensions()</span>. Note that setting an object’s extensibility affects adding properties only and has no impact on modifying or removing them.</p>
<p class="image"><a id="page_213"/><img alt="image" src="f0213-01.jpg"/></p>
<p class="indent">Next, an object has the idea of being sealed, which not only makes it not be extensible, but also sets all of the object’s properties to have <span class="codesample">configurable</span> set to <span class="codesample">false</span>. <span class="codesample">Object.isSealed()</span> will examine the current attribute state, and <span class="codesample">Object.seal()</span> will set it to <span class="codesample">true</span>:</p>
<p class="image"><img alt="image" src="f0213-02.jpg"/></p>
<p class="indent">Lastly, an object can be “frozen.” A frozen object is not only sealed, but also sets all the properties such that no values can be changed. <span class="codesample">Object.isFrozen()</span> examines the attribute state, and <span class="codesample">Object.freeze()</span> will set it to <span class="codesample">true</span>:</p>
<p class="image"><img alt="image" src="f0213-03.jpg"/></p>
<p class="noindent">All three of these object attributes are one way, in that once they are set to <span class="codesample">true</span>, they cannot be reset back to false.</p>
<p class="indent">There are also two new functions for returning a list of an object’s keys/properties (in much the same way as you’d iterate over them with a <span class="codesample">for-in</span> loop, for instance).</p>
<p class="indent"><span class="codesample">Object.keys()</span> returns an array of all the enumerable property names of the object. Recall the earlier discussion of the <span class="codesample">enumerable</span> characteristic of properties, which is <span class="codesample">false</span> by default for all inherited properties, meaning that <span class="codesample">Object.keys()</span> will generally only return direct instance property names that are enumerable:</p>
<p class="image"><img alt="image" src="f0213-04.jpg"/></p>
<p class="noindent"><a id="page_214"/> <span class="codesample">Object.getOwnPropertyNames()</span> will return all property names, regardless of whether they are enumerable or not.</p>
<p class="image"><img alt="image" src="f0214-01.jpg"/></p>
<p class="noindent"><span class="codesample">Object.getPrototypeOf()</span>, which we saw earlier, is a useful addition that allows you to take an existing object and ask for the prototype that was used to create that instance (essentially, the constructor’s <span class="codesample">prototype</span> property at the time of creation). This is basically the read-only version of the not-standardized but still widely adopted (except in IE as of version 10) <span class="codesample">__proto__</span> property of an instance.</p>
<p class="indent">Finally, <span class="codesample">Object.create()</span>, which we saw earlier, has been added natively. One key difference with the native version is that the optional second parameter can be a property descriptor list, identical to what is passed as the second parameter to <span class="codesample">Object.defineProperties()</span>:</p>
<p class="image"><img alt="image" src="f0214-02.jpg"/></p>
<p class="indent"><a id="page_215"/>As you can see, there’s a whole slew of exciting new functionality surrounding objects and properties in ECMAScript 5, so we hope they are embraced by programmers as more and more browsers support the specification.</p>
<h4 class="h4"><a id="ch06lev1sec5"/><strong>JavaScript’s Object-Oriented Reality</strong></h4>
<p class="noindent">Today, object-oriented programming (OOP) is commonly accepted as a good way to structure programs, and full-blown OOP style isn’t always used in JavaScript. You might wonder why this is. The language itself does support the principles of object-oriented programming, which have been demonstrated in the examples of this chapter and are summarized here:</p>
<p class="bullettop"><strong>• Abstraction</strong> An object should characterize a certain abstract idea or task. The object should present an interface to the programmer that provides the features or services one might expect of an object of that type.</p>
<p class="bullet"><strong>• Encapsulation</strong> An object should maintain internally the state necessary to characterize its behavior. This data is usually <em>hidden</em> from other objects and accessed through the public interface the object provides.</p>
<p class="bullet"><strong>• Inheritance</strong> The language should provide the means for specialized objects to be created from more general objects. For example, a general <span class="codesample">Shape</span> object should lend itself to the creation of more specific objects, such as Squares, Triangles, and Circles. These specific objects should “inherit” capabilities from their “ancestors.”</p>
<p class="bullet"><strong>• Polymorphism</strong> Different objects should be able to respond in different ways to the same action. For example, <span class="codesample">Number</span> objects might respond to the operation of addition in the arithmetic sense, while String objects might interpret addition as concatenation. Additionally, objects should be allowed to <span class="codesample"><em>polymorph</em></span> (“change shape”), depending on context.</p>
<p class="indent">Certainly, for many readers, the particular way that JavaScript goes about handling OOP may be a bit foreign if you grew up on Java or C++ classes. We encourage readers to avoid trying to use JavaScript’s dynamic nature to create familiar constructs, as someday a bridge between classical-style OOP and JavaScript’s approach may be handled natively and creating some nonstandard hack may create more headaches than it solves. The advice of going with the grain of JavaScript rather than against it is widely held and should be embraced.</p>
<h4 class="h4"><a id="ch06lev1sec6"/><strong>Summary</strong></h4>
<p class="noindent">JavaScript provides four types of objects: user-defined, native, host, and document. This chapter focused on the fundamental aspects of all objects, as well as the creation and use of user-defined objects. JavaScript is a prototype-based, object-oriented language. New object instances are created with constructors, objects that initialize the properties of new instances. Every object has a prototype property that reflects the prototype of the constructor used to <a id="page_216"/>create it. When an object property is accessed, the interpreter first checks the object’s instance properties for the desired name. If it is not found, the properties of the object’s prototype are checked. This process repeats recursively until it has worked up the chain of inheritance to the top-level object. Most of the time in JavaScript, the creation and management of the objects is straightforward, and programmers are freed from such headaches as memory management. While user-defined objects can be used to create much more modular and maintainable scripts than those written without objects, many JavaScript programmers do not really use them, given the simplicity of their scripts. Instead, the various native, host, and document objects are utilized. The next chapter begins the examination of such objects, starting with native objects—particularly <span class="codesample">Array, Math, Date</span>, and <span class="codesample">String</span>.</p>
</body>
</html>