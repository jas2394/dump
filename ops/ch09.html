<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>JavaScript: The Complete Reference&#153;, Third Edition</title>
<link href="0071741216.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta content="urn:uuid:4d1be0af-c0d3-47b8-9bd4-3edcb4dee196" name="Adept.expected.resource"/>
</head>
<body>
<h3 class="h3b" id="ch09"><a id="page_297"/><strong>CHAPTER 9<br/>JavaScript Object Models</strong></h3>
<p class="noindent">In client-side JavaScript, an object model defines the interface to the various aspects of the browser and the document that can be manipulated in code. Over time the object models supported in browsers have evolved, but for simplicity we may break down object models by browser type and version. We also note that object models may focus on accessing the features and characteristics of a browser—a Browser Object Model (BOM)—as well as the document contained in a browser—the <span class="codesample">Document</span> Object Model (DOM). While this definition of JavaScript’s client side-object model is clear, the unfortunate reality is that the division between the DOM and the BOM has been, at least previous to the rise of HTML5, somewhat fuzzy. Even if such definitions weren’t a concern, object model support in browsers has been somewhat varied. In this chapter, we explore the evolution of JavaScript object models and the general methods of access to bring some clarity before diving into the full W3C DOM and wrappers provided by libraries.</p>
<h4 class="h4"><a id="ch09lev1sec1"/><strong>Object Model Overview</strong></h4>
<p class="noindent">An object model is an interface describing the logical structure of an object and the standard ways in which it can be manipulated. <a class="nounder" href="ch09.html#fig9-1">Figure 9-1</a> presents the “big picture” of all various aspects of what is considered browser-based JavaScript, including its object models. We see four primary components:</p>
<p class="image1"><a id="fig9-1"/><img alt="image" src="f0298-01.jpg"/></p>
<p class="figcap"><strong>Figure 9-1</strong> JavaScript: the “big picture”</p>
<p class="bullettop">• The core JavaScript language (for example, data types, operators, and statements)</p>
<p class="bullet">• The core objects primarily related to data types (for example, <span class="codesample">Date, String</span>, and <span class="codesample">Math</span>)</p>
<p class="bullet">• The browser objects (for example, <span class="codesample">Window, Navigator</span>, and <span class="codesample">Location</span>)</p>
<p class="bullet">• The document objects (for example, <span class="codesample">Document, Form</span>, and <span class="codesample">Image</span>)</p>
<p class="indent">Until this point, we have focused primarily on the first and second aspects of JavaScript. This part of the language is actual fairly consistent between browser types and versions, and corresponds to the features defined by the ECMAScript specification (3<sup>rd</sup> and 5<sup>th</sup> editions) found at <a class="nounder" href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">http://www.ecma-international.org/publications/standards/Ecma-262.htm.</a></p>
<p class="noindent"><a id="page_298"/>However, the objects outside the core ECMAScript specification and their properties and methods do vary. We note in the diagram that it appears that the Browser Object Model (BOM) and <span class="codesample">Document</span> Object Model (DOM) are somewhat intermixed. In fact, in the early days of JavaScript there simply wasn’t much of a distinction between JavaScript’s ad hoc Browser Object Model and the <span class="codesample">Document</span> Object Model—it was just one big mess.</p>
<p class="indent">By studying the history of JavaScript, we can bring some order to the chaos of competing object models and understand exactly how and why the modern object models work the way they do. There have been five distinct object models used in JavaScript:</p>
<p class="bullet"><a id="page_299"/>• Traditional JavaScript object model (Netscape 2 and Internet Explorer 3)</p>
<p class="bullet">• Extended JavaScript object model (Netscape 3)—basis of DOM Level 0</p>
<p class="bullet">• Dynamic HTML-flavored object models (Internet Explorer 4+, Netscape 4 only)</p>
<p class="bullet">• Extended Browser Object Model + standard W3C DOM (modern browsers)</p>
<p class="bullet">• HTML5 Object Model formalizing BOM and extending the DOM</p>
<p class="indenttop">We’ll look at each of these object models in turn and explain their historical motivations, what features and problems they introduced, and where they may be used today. Studying the evolution of JavaScript’s object models will help developers understand why things work the way they do. We strongly encourage readers not to brush off this discussion as historical and opt to immediately code to whatever the latest standard is, believing that eventually all browsers catch up in some pure standards-compliant moment of bliss. Fifteen years later we seem no closer to this point, though hope springs eternal!</p>
<h4 class="h4"><a id="ch09lev1sec2"/><strong>The Initial JavaScript Object Model</strong></h4>
<p class="noindent">If you recall the history of JavaScript presented in <a class="nounder" href="ch01.html#ch01">Chapter 1</a>, the primary design goal of the language was to provide a mechanism to check or manipulate the contents of HTML forms before submitting them to server-side programs. Because of these modest goals, the initial JavaScript object model first introduced in Netscape 2 was rather limited, and it focused on the basic features of the browser and document. <a class="nounder" href="ch09.html#fig9-2">Figure 9-2</a> presents JavaScript’s initial object model, which is pretty similar in Netscape 2 and Internet Explorer 3.</p>
<p class="image1"><a id="fig9-2"/><img alt="image" src="f0300-01.jpg"/></p>
<p class="figcap"><strong>Figure 9-2</strong> The initial JavaScript object model</p>
<p class="indent">You might be curious how the various objects shown in <a class="nounder" href="ch09.html#fig9-2">Figure 9-2</a> are related to JavaScript. Well, we’ve actually used them. For example, <span class="codesample">window</span> defines the properties and methods associated with a browser window. When we have used the JavaScript statement to create a small alert dialog, we actually invoked the <span class="codesample">alert()</span> method of the <span class="codesample">Window</span> object:</p>
<p class="image"><img alt="image" src="f0299-01.jpg"/></p>
<p class="noindent">In fact, we could just as easily have written this to create the same window:</p>
<p class="image"><img alt="image" src="f0299-02.jpg"/></p>
<p class="noindent">Most of the time, because we can infer that we are using the current <span class="codesample">Window</span> object, it is generally omitted.</p>
<p class="indent">The containment hierarchy shown in <a class="nounder" href="ch09.html#fig9-2">Figure 9-2</a> should also make sense once you consider a statement like this:</p>
<p class="image"><img alt="image" src="f0299-03.jpg"/></p>
<p class="noindent">This should look like the familiar output statement used to write text to an HTML document. Once again, we added in the <span class="codesample">“window.”</span> prefix to show the hierarchy, as <a id="page_300"/>we tend to use just <span class="codesample">document.write()</span> in our examples. You might be curious about what all the various objects shown in <a class="nounder" href="ch09.html#fig9-2">Figure 9-2</a> do, so in <a class="nounder" href="ch09.html#tab9-1">Table 9-1</a> we present a brief overview of the traditional browser object. As you can see, the bulk of the objects are contained within the <span class="codesample">Document</span> object, so we’ll look at that one more closely now, but in due time all will be discussed.</p>
<p class="tabcap"><a id="tab9-1"/><strong>Table 9-1</strong> Overview of Core Browser Objects</p>
<p class="image"><img alt="image" src="t0301-01.jpg"/></p>
<hr/>
<p class="note"><strong>NOTE</strong> The <span class="codesample">navigator</span> object more generically should have been called “browser” or “host” and likely been the parent of <span class="codesample">window</span>. It is interesting to call out its name and position, as it reveals both the heavy hand of Netscape in the birth of JavaScript as well as foreshadows the immense number of wrinkles in the language as it matured.</p>
<h4 class="h4"><a id="page_301"/><a id="ch09lev1sec3"/><strong>The <span class="codesample">Document</span> Object</strong></h4>
<p class="noindent">Initially, the <span class="codesample">Document</span> object provided access to select page elements such as anchors, form fields, and links, as well as page properties such as background and text color. We will see that the structure of this object varies considerably from browser to browser, and from version to version, until stabilizing somewhat with the W3C DOM, which provides access to any aspect of a Web page. <a class="nounder" href="ch09.html#tab9-2">Tables 9-2</a> and <a class="nounder" href="ch09.html#tab9-3">9-3</a> list those <span class="codesample">Document</span> properties and methods, respectively, that are the “least common denominator” and available since the very first JavaScript-aware browsers. While some of these are deprecated, they all are still commonly used and will be supported for the foreseeable future. For the sake of brevity, some details and <span class="codesample">Document</span> properties less important to the clarity of the discussion will be omitted for now.</p>
<hr/>
<p class="note"><strong>NOTE</strong> The <span class="codesample"><strong>document.referrer</strong></span> attribute is spelled correctly despite the actual misspelling of the HTTP referrer header.<a id="page_302"/></p>
<p class="tabcap"><a id="tab9-2"/><strong>Table 9-2</strong> Lowest Common Denominator <span class="codesample">Document</span> Properties</p>
<p class="imagea"><img alt="image" src="t0302-01.jpg"/></p>
<p class="image0"><img alt="image" src="t0302-02.jpg"/></p>
<p class="tabcap"><a id="tab9-3"/><strong>Table 9-3</strong> Lowest Common Denominator <span class="codesample">Document</span> Methods</p>
<p class="image"><img alt="image" src="t0303-01.jpg"/></p>
<p class="indent"><a id="page_303"/>Examination of <a class="nounder" href="ch09.html#fig9-2">Tables 9-2</a> and <a class="nounder" href="ch09.html#fig9-3">9-3</a> reveals that the early DOM was indeed very primitive. In fact, the only parts of a document that can be directly accessed are document-wide properties, links, anchors, and forms. There simply was no support for the manipulation of text or images, no support for applets or embedded objects, and no way to access the presentation properties of most elements. We’ll see that all of these capabilities were added later and are widely used today, but first let’s focus on the most basic objects and their use, as everything follows naturally. The following example shows the various document properties printed for a sample document:</p>
<p class="image"><img alt="image" src="f0303-01.jpg"/></p>
<p class="image"><img alt="image" src="f0303-02.jpg"/></p>
<hr/>
<p class="online"><a id="page_304"/><strong>ONLINE</strong> <a class="nounder" href="http://www.javascriptref.com/3ed/ch9/traditionalobjectstester.html">http://javascriptref.com/3ed/ch9/traditionalobjectstester.html</a></p>
<p class="indent">An example of the output of the preceding example is shown in <a class="nounder" href="ch09.html#fig9-3">Figure 9-3</a>.</p>
<p class="image1"><a id="fig9-3"/><img alt="image" src="f0305-01.jpg"/></p>
<p class="figcap"><strong>Figure 9-3</strong> Basic <span class="codesample">Document</span> object properties</p>
<hr/>
<p class="note"><strong>NOTE</strong> You may notice that in some browsers the visited link color does not display. This is purposeful in some browsers to avoid the leakage of history information via a computed link style. This leakage is often called the “history hack.” The authors consider removing computed style access just because of this hack tactic, a piecemeal method of addressing the insecurity of the Web. The implication of such changes is that readers should be warned that, over time, JavaScript features may be eliminated due to the possibility of their exploitation.</p>
<p class="indent"><a id="page_305"/>One thing to note with this example, however, is the fact that many of the properties will not be set if you do not run this with a document containing forms, links, and so on. JavaScript will not create—or, more appropriately in programming parlance, <em>instantiate</em> — a JavaScript object for a markup element that is not present, while you will notice that browsers tend to define default values for certain types of properties such as text and link <a id="page_306"/>colors, regardless of the presence of certain HTML elements or attributes. Our main point here is to be very clear that the HTML elements have corresponding objects in the JavaScripts <span class="codesample">Document</span> object, and that is how the two technologies interact. As an example, a <span class="codesample"><strong>&lt;form&gt;</strong></span> tag has a Form object, and if you set something on the tag it is seen in the object and vice versa. This last idea is the heart of the object model—the bridge between the world of markup in the page and the programming ideas of JavaScript. We now explore how to access and manipulate HTML markup elements from JavaScript.</p>
<hr/>
<p class="tip"><strong>TIP</strong> Given the tight interrelationship between markup and JavaScript objects, it should be no surprise that with bad HTML markup you will often run into problems with your scripts. Despite what people might tell you, you really need to know your HTML if you want to be an expert in browser-based JavaScript.</p>
<h5 class="h5"><a id="ch09lev2sec1"/><strong>Accessing <span class="codesample">Document</span> Elements by Position</strong></h5>
<p class="noindent">As the browser reads an HTML document and forms a parse tree, JavaScript objects are instantiated for all elements that are scriptable. Initially, the number of markup elements that were scriptable in browsers was limited, but with a modern browser it is possible to access any arbitrary HTML element. However, for now let’s concentrate on the HTML elements accessible via the traditional JavaScript object model (also known as DOM Level 0), particularly <span class="codesample"><strong>&lt;form&gt;</strong></span> and its related elements, to keep things simple. We’ll find that this simplicity will serve us well later, as the old ways don’t actually go away with the introduction of the new methods. To illustrate the access method, let’s consider a document like this:</p>
<p class="image"><img alt="image" src="f0306-01.jpg"/></p>
<p class="noindent">Using the traditional JavaScript object model, we can access the <span class="codesample"><strong>&lt;form&gt;</strong></span> tags using</p>
<p class="image"><img alt="image" src="f0306-02.jpg"/></p>
<p class="noindent">which is a collection that looks like an array in a basic sense. So if we were to simply look at the number of forms in the example document:</p>
<p class="image"><img alt="image" src="f0306-03.jpg"/></p>
<p class="noindent">we would see the following:</p>
<p class="image1"><a id="page_307"/><img alt="image" src="f0307-01.jpg"/></p>
<p class="noindent">Then we might access the first <span class="codesample"><strong>&lt;form&gt;</strong></span> in the document using this path-style syntax:</p>
<p class="image"><img alt="image" src="f0307-02.jpg"/></p>
<p class="noindent">To see that in action, let’s alert the value of its <span class="codesample"><strong>action</strong></span> attribute, like so:</p>
<p class="image"><img alt="image" src="f0307-03.jpg"/></p>
<p class="image1"><img alt="image" src="f0307-04.jpg"/></p>
<p class="indent">To access the <span class="codesample"><strong>action</strong></span> attribute of the second <span class="codesample"><strong>&lt;form&gt;</strong></span> tag, we would use</p>
<p class="image"><img alt="image" src="f0307-05.jpg"/></p>
<p class="noindent">and so on. However, accessing <span class="codesample">window.document.forms[5]</span> or other values would cause a problem since there are only two form objects instantiated by each of the <span class="codesample"><strong>&lt;form&gt;</strong></span> tags.</p>
<p class="indent">If we go back and look again at <a class="nounder" href="ch09.html#fig9-2">Figure 9-2</a>, notice that the <span class="codesample">forms[]</span> collection also contains an <span class="codesample">elements[]</span> collection. The <span class="codesample">elements[]</span> collection contains the various form fields such as text fields, buttons, pull-downs, and so on. It does not, however, contain other arbitrary markup elements. Following the basic containment concept to reach the first form element in the first form of the document, we would use syntax that shows this inclusion path, like so:</p>
<p class="image"><img alt="image" src="f0307-06.jpg"/></p>
<p class="indent">While this array-based access is straightforward, the major downside is that it relies on the position of the HTML tag in the document. If the tags are moved around, the JavaScript will likely break. A better approach is to rely on the name of the object.</p>
<h5 class="h5"><a id="ch09lev2sec2"/><strong>Accessing <span class="codesample">Document</span> Elements by Name</strong></h5>
<p class="noindent">Markup elements in a Web page really should be named to allow scripting languages to easily read and manipulate them. The basic way to attach a unique identifier to an HTML element is by using the <span class="codesample"><strong>id</strong></span> attribute, which is associated with nearly every HTML element. For example, to name a particular enclosed emboldened piece of text that reads “SuperImportant,” you could use the markup shown here:</p>
<p class="image"><img alt="image" src="f0307-07.jpg"/></p>
<p class="indent"><a id="page_308"/>Just like choosing unique variable names within JavaScript, naming tags in markup is very important since these tags create objects within JavaScript. If you have name collisions in your markup, you are probably going to break your script. Web developers are encouraged to adopt a consistent naming style and to avoid using potentially confusing names that include the names of HTML elements themselves. For example, “button” does not make a very good name for a form button, will certainly lead to confusing code, and may even interfere with scripting language access.</p>
<p class="indent">Before the introduction of HTML 4 and XHTML, the <span class="codesample"><strong>name</strong></span> attribute instead of <span class="codesample"><strong>id</strong></span> was used to expose items to scripting. For backward compatibility, the <span class="codesample"><strong>name</strong></span> attribute is defined for <span class="codesample"><strong>&lt;a&gt;, &lt;applet&gt;, &lt;button&gt;, &lt;embed&gt;</strong>, <span class="codesample"><strong>&lt;form&gt;</strong></span>, <strong>&lt;frame&gt;, &lt;iframe&gt;, &lt;img&gt;, &lt;input&gt;, &lt;map&gt;, &lt;object&gt;, &lt;select&gt;</strong></span>, and <span class="codesample"><strong>&lt;textarea&gt;</strong></span>. Notice that the occurrence of the <span class="codesample"><strong>name</strong></span> attribute corresponds closely to the traditional Browser Object Model.</p>
<hr/>
<p class="note"><strong>NOTE</strong> Both <span class="codesample"><strong>&lt;meta&gt;</strong></span> and <span class="codesample"><strong>&lt;param&gt;</strong></span> support an attribute called <span class="codesample"><strong>name</strong></span>, but these have totally different meanings that are unrelated to script access.</p>
<p class="indent">Generally, it is assumed that <span class="codesample"><strong>name</strong></span> is always superseded by <span class="codesample"><strong>id</strong></span>. This is <span class="codesample">true</span>, to some extent, but not for form fields and frame names, practically speaking. For example, with form elements the <span class="codesample"><strong>name</strong></span> attribute is used to determine the name-value pairs to be sent to a server-side program and should not be eliminated. Browsers do not use <span class="codesample"><strong>id</strong></span> in that manner. To be on the safe side, you could use <span class="codesample"><strong>name</strong></span> and <span class="codesample"><strong>id</strong></span> attributes on form elements. So, we would write the following:</p>
<p class="image"><img alt="image" src="f0308-01.jpg"/></p>
<p class="noindent">Then, to access the form from JavaScript, we would use either</p>
<p class="image"><img alt="image" src="f0308-02.jpg"/></p>
<p class="noindent">or simply</p>
<p class="image"><img alt="image" src="f0308-03.jpg"/></p>
<p class="noindent">because the <span class="codesample">Window</span> object can be assumed when we are referencing the current active browser window. The text field would be accessed in a similar fashion by using <span class="codesample">document.myForm.userName</span> with the traditional path-style syntax or using a more modern DOM syntax such as this:</p>
<p class="image"><img alt="image" src="f0308-04.jpg"/></p>
<hr/>
<p class="note"><strong>NOTE</strong> To ensure compatibility, having matching <span class="codesample"><strong>name</strong></span> and <span class="codesample"><strong>id</strong></span> attribute values when both are defined is a good idea. However, be careful—some tags, particularly radio buttons, must have nonunique <span class="codesample"><strong>name</strong></span> values, but require unique <span class="codesample"><strong>id</strong></span> values. Once again, this should reference that <span class="codesample"><strong>id</strong></span> is not simply a replacement for <span class="codesample"><strong>name</strong></span>; they are different in purpose. Furthermore, do not discount the old-style approach, a deep look at modern libraries shows such syntax style used for performance and ease purposes at times. Your goal should always be in favor of compatibility.</p>
<h6 class="h6"><a id="page_309"/><strong>Accessing Objects Using Associative Arrays</strong></h6>
<p class="noindent">Most of the arrays in the <span class="codesample">Document</span> object are associative in that they can be indexed with a string denoting the name of the element you wish to access, as opposed to the standard numerical approach to the arrays. The name, as we have also seen, is assigned with either HTML’s <span class="codesample"><strong>name</strong></span> or <span class="codesample"><strong>id</strong></span> attribute for the tag. Of course, many older browsers will only recognize the setting of an element’s name using the <span class="codesample"><strong>name</strong></span> attribute. Consider the following HTML:</p>
<p class="image"><img alt="image" src="f0309-01.jpg"/></p>
<p class="indent">You can access the form as <span class="codesample">document.forms[“myForm2”]</span>. Further, you may use the <span class="codesample">elements[]</span> array of the <span class="codesample">Form</span> object to access the field as <span class="codesample">document.forms[“myForm2”] .elements[“user”]</span>. This is often simplified as just <span class="codesample">document.myForm2</span> and <span class="codesample">document.myForm2.user</span> to use a traditional tree path style.</p>
<p class="indent">Internet Explorer generalized these associative arrays and calls them <em>collections</em> in light of what later became the term under the DOM standard. Collections under JavaScript’s DOM implementation allow for the standard <span class="codesample">[ ]</span> syntax, but also allow for syntax like <span class="codesample">document.forms.item (0)</span> to access the first form, <span class="codesample">document.forms.item (1)</span> to access the second, and so on. In most senses, it would seem as if collections and arrays are pretty much the same thing, and few developers end up using the <span class="codesample">item()</span> style syntax. There are indeed some differences. For example, collections aren’t arrays, and thus standard <span class="codesample">Array</span> methods will not work on them. However, since most people are doing simple iterations and access, this likely won’t be too much of an issue.</p>
<h6 class="h6"><strong>Accessing Objects Using Basic DOM Methods</strong></h6>
<p class="noindent">In today’s modern environment, we commonly see the use of the accessor method <span class="codesample">document.getElementById (<em>id</em>)</span> to fetch an object. This will work on any HTML with an <span class="codesample"><strong>id</strong></span> value uniquely set. So given the following markup:</p>
<p class="image"><img alt="image" src="f0309-02.jpg"/></p>
<p class="noindent">as before we would use</p>
<p class="image"><img alt="image" src="f0309-03.jpg"/></p>
<p class="noindent">to fetch the object of interest. The DOM standard acknowledges that form fields will retain the <span class="codesample"><strong>name</strong></span> attribute, so we might fetch the user field using the <span class="codesample">getElementsByName</span> (<em><span class="codesample">name</span></em>) method as shown here:</p>
<p class="image"><img alt="image" src="f0309-04.jpg"/></p>
<p class="noindent">Notice that the method is plural (elements), as there may be numerous forms in the page that have form fields with the same <span class="codesample"><strong>name</strong></span> value. We use simple array item access syntax to then scope to the first one, as we know it is the one we want. Alternatively, we could use the DOM’s item-accessing methods, like so:</p>
<p class="image"><img alt="image" src="f0309-05.jpg"/></p>
<p class="indent"><a id="page_310"/>We see that the modern DOM supports numerous ways to find objects. For example, we may find all the <span class="codesample"><strong>&lt;input&gt;</strong></span> tags in the document using</p>
<p class="image"><img alt="image" src="f0310-01.jpg"/></p>
<p class="noindent">and then iterate over the collection performing various actions. In some sense, this method would allow us to create arbitrary collections to suit our needs. For example, here we create a collection of all the <span class="codesample"><strong>&lt;p&gt;</strong></span> tags in the document:</p>
<p class="image"><img alt="image" src="f0310-02.jpg"/></p>
<p class="indent">If you were concerned with the fact that <span class="codesample"><strong>&lt;p&gt;</strong></span> tags should only occur in the document body, you might even scope the search for matching elements:</p>
<p class="image"><img alt="image" src="f0310-03.jpg"/></p>
<p class="noindent">The preceding example suggests that the DOM provides a degree of scoping object searches well beyond the simple path scheme in early browsers. For example, given the following document, we see five paragraph elements:</p>
<p class="image"><img alt="image" src="f0310-04.jpg"/></p>
<p class="indent">If we were interested in finding the paragraphs that are solely within the <span class="codesample"><strong>&lt;div&gt;</strong></span> tag with the <span class="codesample"><strong>id</strong></span> value of <span class="codesample"><strong>“note”</strong></span>, we might use something like</p>
<p class="image"><img alt="image" src="f0310-05.jpg"/></p>
<p class="noindent">which would return a collection of two items rather than getting all the <span class="codesample"><strong>&lt;p&gt;</strong></span> tags in the document. This DOM tree scoping may remind some readers of CSS rules such as the following:</p>
<p class="image"><a id="page_311"/><img alt="image" src="f0311-01.jpg"/></p>
<p class="indent">If an object model is a programmatic interface to mark up, it would seem that a well-known and understood selection syntax, as CSS provides, would be quite useful. That’s exactly what most browsers and the DOM specification now support.</p>
<h6 class="h6"><strong>Modern Methods of Object Access</strong></h6>
<p class="noindent">Finding objects using the traditional DOM Level 0 or later, more modern, DOM implementations can be a bit cumbersome. Fortunately, libraries and the specifications themselves have stepped in to fill the gaps. Finding collections of items is quite easy. First, we see the introduction of a method such as <span class="codesample">document.getElementsByClassName (<em>classnametofind</em>)</span>. Given some markup like</p>
<p class="image"><img alt="image" src="f0311-02.jpg"/></p>
<p class="noindent">we might fetch the corresponding objects, like so:</p>
<p class="image"><img alt="image" src="f0311-03.jpg"/></p>
<p class="noindent">This would return a standard collection to loop over.</p>
<p class="indent">Even more interesting, we might use a CSS selector to find something of interest. For example, using the same markup we may find all the nested <span class="codesample"><strong>&lt;span&gt;</strong></span> tags with the class of interest using the following code:</p>
<p class="image"><img alt="image" src="f0311-04.jpg"/></p>
<p class="noindent">Once again, a collection will be returned that we may loop over to affect various page elements.</p>
<p class="indent">If you sense a pattern in the examples of finding elements in the document tree in a multitude of ways, you understand what we are illustrating. We will select elements with various DOM queries and then perform actions on them like deleting or changing them. A summary of the various selection methods can be found in <a class="nounder" href="ch09.html#tab9-4">Table 9-4</a>. This selection of page elements is, in fact, such a common task in JavaScript that many popular libraries implement generic “selection” methods that provide nice, shorthand method names, such as <span class="codesample">$()</span>, to access DOM elements in flexible and powerful ways. We’ll look at this in due time; our goal here is simply initial exposure to the selection schemes. In <a class="nounder" href="ch10.html#ch10">Chapter 10</a>, we will present these ideas in depth.</p>
<p class="tabcap"><a id="tab9-4"/><strong>Table 9-4</strong> Overview of DOM Object Selection Schemes</p>
<p class="imagea"><img alt="image" src="t0312-01.jpg"/></p>
<p class="image0"><img alt="image" src="t0312-02.jpg"/></p>
<h4 class="h4"><a id="page_312"/><a id="ch09lev1sec4"/><strong>Simple Event Handling</strong></h4>
<p class="noindent">Now that we have some idea of how to access page objects, we need to see how to monitor these objects for user activity. The primary way in which scripts respond to user actions is through <em>event handlers</em>. An event handler is JavaScript code that is associated with a particular part of the document and a particular “event.” The code is executed if and when the given event occurs at the part of the document to which it is associated. Common events include <span class="codesample">Click, MouseOver</span>, and <span class="codesample">MouseOut</span>, which occur when the user clicks, places the mouse over, or moves the mouse away from a portion of the document, respectively. These events are commonly associated with form buttons, form fields, images, and links, and are used for tasks such as form field validation and rollover buttons. It is important to remember that not every object is capable of handling every type of event. The events an object can handle are largely a reflection of the way the object is most commonly used.</p>
<h5 class="h5"><a id="ch09lev2sec3"/><strong>Setting Event Handlers Inline</strong></h5>
<p class="noindent">You have probably seen event handlers before in HTML. The following simple example shows users an alert box when they click the button:</p>
<p class="image"><a id="page_313"/><img alt="image" src="f0313-01.jpg"/></p>
<p class="indent">The <span class="codesample"><strong>onclick</strong></span> attribute of the <span class="codesample"><strong>&lt;input&gt;</strong></span> tag is used to bind the given code to the button’s <span class="codesample">Click</span> event. Whenever the user clicks the button, the browser sends a <span class="codesample">Click</span> event to the <span class="codesample">Button</span> object, causing it to invoke its <span class="codesample"><strong>onclick</strong></span> event handler.</p>
<h5 class="h5"><a id="ch09lev2sec4"/><strong>Direct Assignment of Event Handlers</strong></h5>
<p class="noindent">How does the browser know where to find the object’s event handler? This is dictated by the part of the DOM known as the <em>event model</em>. An event model is simply a set of interfaces and objects that enable this kind of event handling. In most major browsers, an object’s event handlers are accessible as properties of the object itself. So instead of using markup to bind an event handler to an object, we can do it with pure JavaScript. The following code is equivalent to the previous example:</p>
<p class="image"><img alt="image" src="f0313-02.jpg"/></p>
<p class="indent">We define an anonymous function containing the code for the event handler, and then set the button’s <span class="codesample">onclick</span> property equal to it. If we later wanted to remove it, we would set the value of the listener to <span class="codesample">null</span>:</p>
<p class="image"><img alt="image" src="f0313-03.jpg"/></p>
<p class="noindent">The previous method is fine in most cases but has some limitations, most obviously when later another script wishes to add a click handler to the same button. In effect, the direct assignment will overwrite our previous handler.</p>
<p class="indent">We further note what should hopefully be obvious, which is that it is not required to associate an anonymous function. For example, the following is a legitimate approach as well:</p>
<p class="image"><img alt="image" src="f0313-04.jpg"/></p>
<h5 class="h5"><a id="ch09lev2sec5"/><strong>Setting Event Listeners</strong></h5>
<p class="noindent">The DOM provides a much richer and more appropriate way to assign events than with direct assignment using the <span class="codesample">addEventListener (<em>type, function, useCapture</em>)</span> method. The basic idea is that you fetch a DOM element and then use this method to assign the <span class="codesample"><em>type</em></span> of event “click” to a particular function to handle the event. You also should pass a third Boolean value called <span class="codesample"><em>useCapture</em></span> to indicate the direction in which events should flow. Typically, events flow upward from the trigger element, but they may flow downward from <span class="codesample">Document</span> to the target element if the third argument to <span class="codesample">addEventListener()</span> is set to <span class="codesample">true</span>; otherwise, set it to <span class="codesample">false</span> to have events handling in the bubble up phase, <a id="page_314"/>which is what we’ll do here. We’ll explore the specific nuances of event flow in <a class="nounder" href="ch11.html#ch11">Chapter 11</a>, but for now let’s see a simple example that binds a button’s click event:</p>
<p class="image"><img alt="image" src="f0314-01.jpg"/></p>
<p class="noindent">If we wanted to add another event handler, we would simply later issue a similar statement such as the following, causing both events to fire as expected:</p>
<p class="image"><img alt="image" src="f0314-02.jpg"/></p>
<p class="indent">To remove events using this scheme, we should invoke the</p>
<p class="noindent"><span class="codesample">removeEventListener (<em>type, function, useCapture</em>)</span> off the bound DOM element. Given the previous example, you might be tempted then to use this statement:</p>
<p class="image"><img alt="image" src="f0314-03.jpg"/></p>
<p class="noindent">Unfortunately, this won’t work because we are using a different anonymous function than the bound one from before. Instead, we should initially bind the event handler to a particular function, like so:</p>
<p class="image"><img alt="image" src="f0314-04.jpg"/></p>
<p class="noindent">Then later, it is easy enough to remove the listeners in a similar fashion:</p>
<p class="image"><img alt="image" src="f0314-05.jpg"/></p>
<p class="indent">A simple example of DOM events can be found online, with a more detailed discussion found in <a class="nounder" href="ch10.html#ch10">Chapter 10</a>.</p>
<hr/>
<p class="online"><strong>ONLINE</strong> <a class="nounder" href="http://www.javascriptref.com/3ed/ch9/eventlistener.html">http://javascriptref.com/3ed/ch9/eventlistener.html</a></p>
<h6 class="h6"><strong>Cross-Browser Event-Binding Preview</strong></h6>
<p class="noindent">Sadly, Internet Explorer browsers prior to version 9 do not support the <span class="codesample">addEventListener()</span> syntax, but instead supported proprietary methods called <span class="codesample">attachEvent (<em>event, function</em>)</span> and <span class="codesample">detachEvent (<em>event, function</em>)</span>. The syntax is strikingly similar, except that you no longer pass “click” but instead “onclick,” and there is no need to specify event flow, as events under older Internet Explorer have only one event flow method—bubbling. The simple example addition of an event under proprietary Internet Explorer syntax looks like this:</p>
<p class="image"><a id="page_315"/><img alt="image" src="f0315-01.jpg"/></p>
<p class="noindent">while the removal would look like this:</p>
<p class="image"><img alt="image" src="f0315-02.jpg"/></p>
<p class="noindent">A full example can be found online.</p>
<hr/>
<p class="online"><strong>ONLINE</strong> <a class="nounder" href="http://www.javascriptref.com/3ed/ch9/ieevents.html">http://javascriptref.com/3ed/ch9/ieevents.html</a></p>
<p class="indenttop">Obviously, we could write a wrapper function that tries to abstract away the event-handling details. For example, here we write two methods in our namespace wrapper object <span class="codesample"><em>JSREF</em></span> for adding (<em><span class="codesample">addEvent</span></em>) and removing (<em><span class="codesample">removeEvent</span></em>) events regardless of the browser in play:</p>
<p class="image"><img alt="image" src="f0315-03.jpg"/></p>
<p class="noindent">This would then allow us to say something like</p>
<p class="image"><img alt="image" src="f0315-04.jpg"/></p>
<p class="noindent">to add an event to the button or</p>
<p class="image"><img alt="image" src="f0315-05.jpg"/></p>
<p class="noindent">to remove an event from our test button. A rework of this simple example can be found online.</p>
<hr/>
<p class="online"><strong>ONLINE</strong> <a class="nounder" href="http://www.javascriptref.com/3ed/ch9/crossbrowserevents.html">http://javascriptref.com/3ed/ch9/crossbrowserevents.html</a></p>
<p class="indenttop">Admittedly, the wrapper is quite simple, and libraries will do a better job in ironing out little wrinkles and managing the memory problems that often ensue when using event handlers, but it does serve our purpose of illustrating the continued variation between not only browser object models but event models as well.</p>
<h5 class="h5"><a id="page_316"/><a id="ch09lev2sec6"/><strong>Invoking Event Handlers</strong></h5>
<p class="noindent">You can cause an event to occur on an object just as easily as you can set its handler. Objects have a method named after each event they can handle. For example, the <span class="codesample">Button</span> object has a <span class="codesample">click()</span> method that causes its <span class="codesample">onclick</span> handler to execute (or to “fire,” as many say). We can easily cause the click event defined in the previous two examples to fire:</p>
<p class="image"><img alt="image" src="f0316-01.jpg"/></p>
<p class="indent">There is obviously much more to event handlers than we have described here. All major browsers implement sophisticated event models that provide developers an extensive flexibility when it comes to events. For example, if you have to define the same event handler for a large number of objects, you can bind the handler once to an object higher up the hierarchy rather than binding it to each child individually. A more complete discussion of event handlers is found in <a class="nounder" href="ch11.html#ch11">Chapter 11</a>.</p>
<h4 class="h4"><a id="ch09lev1sec5"/><strong>JavaScript + DOM + Selection + Events = Program</strong></h4>
<p class="noindent">Now that we have seen all the components of the traditional object model, it is time to show how all the components are used together. As we have seen previously, by using a tag’s name or determining its position, it is fairly easy to reference an occurrence of an HTML element that is exposed in the JavaScript object model. For example, given</p>
<p class="image"><img alt="image" src="f0316-02.jpg"/></p>
<p class="noindent">we would traditionally use</p>
<p class="image"><img alt="image" src="f0316-03.jpg"/></p>
<p class="noindent">to access the field named <span class="codesample"><strong>userName</strong></span> in this form or with a more modern method:</p>
<p class="image"><img alt="image" src="f0316-04.jpg"/></p>
<p class="indent">Yet regardless of access method, the question should now be, how do you manipulate that tag’s properties? The key to understanding JavaScript’s object model is that generally HTML elements’ attributes are exposed as JavaScript object properties. So given that a text field in HTML has the basic syntax of</p>
<p class="image"><img alt="image" src="f0316-05.jpg"/></p>
<p class="indent">then, given our last example, <span class="codesample"><em>elementObject</em>.type</span> references the input field’s <span class="codesample"><strong>type</strong></span> attribute value. To retrieve the <span class="codesample"><em>elementObject</em></span> and access the <span class="codesample">type</span> property, we might use a traditional path such as <span class="codesample">document.myForm.userName.type</span> or some other scheme such as <span class="codesample">document.getElementById (“userName”).type</span>. We can take this further so that <span class="codesample"><em>elementObject</em>.size</span> references its displayed screen size in characters, <span class="codesample"><em>elementObject</em>.value</span> represents the value typed in, and so on. The following simple <a id="page_317"/>example puts everything together and shows how the contents of a form field are accessed and displayed dynamically in an alert window by referencing the fields by name:</p>
<p class="image"><img alt="image" src="f0317-01.jpg"/></p>
<hr/>
<p class="online"><strong>ONLINE</strong> <a class="nounder" href="http://www.javascriptref.com/3ed/ch9/meetandgreet.html">http://javascriptref.com/3ed/ch9/meetandgreet.html</a></p>
<p class="indent">Not only can we read the contents of page elements, particularly form fields, we can update their contents using JavaScript. Using form fields that are the most obvious candidates for this, we modify the previous example to write our response to the user in another form field:</p>
<p class="image"><img alt="image" src="f0317-02.jpg"/></p>
<p class="image"><img alt="image" src="f0317-03.jpg"/></p>
<hr/>
<p class="online"><a id="page_318"/><strong>ONLINE</strong> <a class="nounder" href="http://www.javascriptref.com/3ed/ch9/meetandgreet2.html">http://javascriptref.com/3ed/ch9/meetandgreet2.html</a></p>
<p class="indent">Instead of writing to a form field or alerting a message, we might instead output the greeting to the document itself. We’ll use the convenient <span class="codesample">innerHTML</span> property to set the contents of an element:</p>
<p class="image"><img alt="image" src="f0318-01.jpg"/></p>
<p class="image"><img alt="image" src="f0318-02.jpg"/></p>
<hr/>
<p class="online"><a id="page_319"/><strong>ONLINE</strong> <a class="nounder" href="http://www.javascriptref.com/3ed/ch9/meetandgreet3.html">http://javascriptref.com/3ed/ch9/meetandgreet3.html</a></p>
<p class="indent">In future examples, we’ll continue to not only modify documents but change the look and style of the content. However, for now we should wind down this basic introduction with a quick tour of the evolution of the JavaScript object models.</p>
<h4 class="h4"><a id="ch09lev1sec6"/><strong>The Evolution of the JavaScript Object Model</strong></h4>
<p class="noindent">So far, our discussion has focused primarily on the generic features common to all object models, regardless of browser version. Not surprisingly, every time a new version was released, browser vendors extended the functionality of the <span class="codesample">Document</span> object in various ways. Bugs were fixed, access to a greater portion of the document was added, and the existing functionality was continually improved upon.</p>
<p class="indent">The gradual evolution of the DOM was a good thing in the sense that more recent object models allow you to carry out a wider variety of tasks more easily. However, this evolution posed, and continues to pose, major problems for Web developers. The biggest issue is that JavaScript object models of different browsers evolved in different directions. New, proprietary features were added to facilitate the realization of new ideas such as Dynamic HTML (DHTML), Ajax, and even HTML5. Whether it was premillennial Web or well into Web 2.0, Web developers have wrestled with targeting different browser object models and shifting compliance for standards such as the DOM and HTML5. We briefly discuss the past so that readers understand where we came from and preview the future with HTML5 to see that the past lives on, both in its ugliness and in its hard lessons.</p>
<h5 class="h5"><a id="ch09lev2sec7"/><strong>The Early Evolution of Browser Object Models</strong></h5>
<p class="noindent">The pre-W3C DOM object models quickly evolved from providing the rudimentary form field access features demonstrated earlier in the chapter into a proprietary mess before eventually returning to some sanity. We divide the early object models into the following groups:</p>
<p class="bullettop">• Traditional object model (Netscape 2 and Internet Explorer 3)</p>
<p class="bullet">• Extended object model (Netscape 3)</p>
<p class="bullet">• DHTML object models (Netscape 4, Internet Explorer 4+)</p>
<h6 class="h6"><strong>Traditional Model</strong></h6>
<p class="noindent">The traditional object model included support for form field manipulation and basic page details. It was shown visually in <a class="nounder" href="ch09.html#fig9-2">Figure 9-2</a> and detailed in <a class="nounder" href="ch09.html#tab9-1">Table 9-1</a>. Internet Explorer 3 supported pretty much the same model as Netscape 2, although it added a <span class="codesample">frames[]</span> collection under the <span class="codesample">Document</span> object. This collection contained all the instances of objects corresponding to the <span class="codesample"><strong>&lt;iframe&gt;</strong></span> tags in the document. A visual representation of the Internet Explorer 3 object model can be found in <a class="nounder" href="ch09.html#fig9-4">Figure 9-4</a>.</p>
<p class="image1"><a id="fig9-4"/><img alt="image" src="f0320-01.jpg"/></p>
<p class="figcap"><strong>Figure 9-4</strong> Internet Explorer’s slightly modified traditional model</p>
<p class="indent"><a id="page_320"/>For the short period of time when Netscape 2 and Internet Explorer 3 coexisted as the latest versions of the respective browsers, object models were in a comfortable state of unity. It wouldn’t last long.</p>
<h6 class="h6"><strong>Extended Object Model (Netscape 3)</strong></h6>
<p class="noindent">Netscape 3’s extended object model opened the door for the first primitive DHTML-like applications. It exposes more of document content to scripts by providing the ability to access embedded objects, applets, plug-ins, and images. This object model is shown in <a class="nounder" href="ch09.html#fig9-5">Figure 9-5</a>, and the major additions to the <span class="codesample">Document</span> object are listed in <a class="nounder" href="ch09.html#tab9-5">Table 9-5</a>.</p>
<p class="image1"><a id="fig9-5"/><img alt="image" src="f0321-01.jpg"/></p>
<p class="figcap"><strong>Figure 9-5</strong> Netscape 3’s extended traditional object model</p>
<p class="tabcap"><a id="tab9-5"/><strong>Table 9-5</strong> Collections Introduced by Netscape 3</p>
<p class="image"><img alt="image" src="t0321-01.jpg"/></p>
<hr/>
<p class="note"><strong>NOTE</strong> The Netscape 3 object model without the <span class="codesample">embeds[]</span> and <span class="codesample">plugins[]</span> collections is the core of the DOM Level 0 standard and thus is quite important to know.</p>
<h5 class="h5"><a id="ch09lev2sec8"/><strong>DHTML-Oriented Object Models</strong></h5>
<p class="noindent">The DOM of version 4 browsers marks the point at which support for so-called Dynamic HTML (DHTML) begins. Outside of swapping images in response to user events, there was little one could do to bring Web pages alive before Netscape 4. Major changes in this version include support for the proprietary <span class="codesample"><strong>&lt;layer&gt;</strong></span> tag, additions to Netscape’s event model, as well as the addition of <span class="codesample">Style</span> objects and the means to manipulate them. <a class="nounder" href="ch09.html#fig9-6">Figure 9-6</a> shows the essentials of Netscape 4’s object model, and the most interesting new properties of the <span class="codesample">Document</span> object are listed in <a class="nounder" href="ch09.html#fig9-6">Table 9-6</a> and shown in <a class="nounder" href="ch09.html#fig9-6">Figure 9-6</a>.</p>
<p class="tabcap"><a id="tab9-6"/><strong>Table 9-6</strong> Overview of DOM Object Selection Schemes</p>
<p class="image"><img alt="image" src="t0322-01.jpg"/></p>
<p class="image1"><a id="fig9-6"/><img alt="image" src="f0322-01.jpg"/></p>
<p class="figcap"><strong>Figure 9-6</strong> Netscape 4’s not soon enough forgotten object model</p>
<p class="indent"><a id="page_321"/>Fortunately for us, today most of the aspects of the Netscape 4 object model are regulated to mere historical footnotes in Web development. However, Microsoft’s contribution to the DHTML wars has lived on.</p>
<h5 class="h5"><a id="page_322"/><a id="ch09lev2sec9"/><strong>Internet Explorer 4’s DHTML Object Model</strong></h5>
<p class="noindent">Like version 4 of Netscape’s browser, Internet Explorer 4 lays the foundations for DHTML applications by exposing much more of the page to JavaScript. In fact, it went much further than Netscape 4 by representing <em>every</em> HTML element as an object in a collection called <a id="page_323"/> <span class="codesample">document.all[].</span> Of course, it does so in a manner incompatible with Netscape 4’s object model, so this generation of object models thrust JavaScript developers into the world of handling significant variations across browsers. The core object model of Internet Explorer 4 is shown in <a class="nounder" href="ch09.html#fig9-7">Figure 9-7</a>.</p>
<p class="image1"><a id="fig9-7"/><img alt="image" src="f0323-01.jpg"/></p>
<p class="figcap"><strong>Figure 9-7</strong> Internet Explorer 4+ object model</p>
<p class="tabcap"><a id="tab9-7"/><strong>Table 9-7</strong> Collections Introduced in Internet Explorer 4+</p>
<p class="image"><img alt="image" src="t0324-01.jpg"/></p>
<p class="indent">Inspection of <a class="nounder" href="ch09.html#fig9-7">Figure 9-7</a> reveals that Internet Explorer 4 supports the basic object model of Netscape 2 and Internet Explorer 3, plus most of the features of Netscape 3 and many of its own features. <a class="nounder" href="ch09.html#tab9-7">Table 9-7</a> lists some important new properties introduced in Internet Explorer 4.</p>
<h5 class="h5"><a id="ch09lev2sec10"/><strong>Beyond the DHTML Object Models</strong></h5>
<p class="noindent">After the initial browser wars, the browsers continued to evolve albeit a bit slower. In fact, the Internet Explorer 5.<em>x</em> and 6.<em>x</em> DOM is very similar to that of Internet Explorer 4. New features include an explosive rise in the number of properties and methods available in the objects of the DOM and proprietary enhancements allowing the development of reusable DHTML components. Internet Explorer 5.5 continued the trend of new features, and by Internet Explorer 6 we see that Internet Explorer implemented significant portions of the W3C DOM. Internet Explorer 7 and 8 continued the trend with some fixes, though Internet Explorer 9 moved radically toward more standards support. However, regardless of version, the Internet Explorer browsers continue to support all of the old features and developers continue to use them.</p>
<p class="indent"><a id="page_324"/>The Netscape evolution ended at Navigator 4 and started over again with Netscape 6, following a pure W3C DOM style. This browser later evolved into Firefox. The WebKit engine that powers Safari and Chrome, as well as the Opera browser, focused more on a W3C domain standard. However, it should be noted that all of these standards-focused browsers support the traditional object models, as well as many Internet Explorer proprietary features.</p>
<p class="indent">What is often misunderstood by many JavaScript aficionados is what standards compliance actually means. Close inspection of browsers’ JavaScript and DOM implementations shows that gaps in execution are there and that there is plenty of room for interpretation of meaning at times. Furthermore, innovation continues and browser vendors introduce features to gain new users or excite developers. It is interesting to observe the rancor that some professionals place on the effects of the free market on standards. Innovation is somewhat inevitable outside the standards track, and what initially is maligned as proprietary often becomes a de facto or approved standard later on. For example, Internet Explorer’s <span class="codesample">innerHTML</span> property was initially widely scorned, but today it is ubiquitous in Web development, though often hidden in a library. Apple’s Safari first implemented the <span class="codesample"><strong>&lt;canvas&gt;</strong></span> tag and its related API and was harassed for building proprietary features, and now the technology is considered open. Ajax was introduced via Microsoft’s proprietary <span class="codesample">XMLHttpRequest</span> object, and on and on the examples go. Today, most of these ideas are standard under HTML5 or related specifications. Given this pattern, readers are encouraged to sit out the heated debates and figure out how to make new and motivating JavaScript features work now and into the future, because some nirvana of perfect specification compliance across browsers is quite unlikely, if history is any guide. In fact, we’ll demonstrate this idea in <a class="nounder" href="ch10.html#ch10">Chapter 10</a> as we explore the standard DOM Level 1 and DOM Level 2 APIs and reveal that, even here, with a standard browser details still abound. Libraries often try to mask these differences; however, they do continue to exist. This suggests to us that, underneath it all, the more things change, the more they stay the same—at least as far as JavaScript variability is concerned.</p>
<h4 class="h4"><a id="page_325"/><a id="ch09lev1sec7"/><strong>Summary</strong></h4>
<p class="noindent">This chapter gives a basic introduction to client-side JavaScript object models. We studied the traditional DOM’s containment hierarchy but also presented other access schemes such as <span class="codesample">getElementById(), getElementsByName(), getElementsByClassName()</span> and <span class="codesample">querySelectorAll()</span>. We briefly demonstrated how to tie together object access and event models to make a small Web application. We spent some time discussing the JavaScript object model to explain how it has evolved over time so that the wrinkles of JavaScript coding seem a bit more purposeful, but also to explain the basis of DOM Level 0. The chapter also illustrated the divergent and incompatible nature of different browsers’ object and event implementations and demonstrated simple ways we might abstract them away. In <a class="nounder" href="ch10.html#ch10">Chapter 10</a>, we continue our exploration of Web page manipulation by covering the W3C DOM API in great detail and follow with an in-depth event discussion. Once all this ground work is in place, we can discuss applied JavaScript and how libraries may be employed to make coding JavaScript more fun and productive.<a id="page_326"/></p>
</body>
</html>